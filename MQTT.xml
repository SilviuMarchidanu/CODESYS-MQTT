<?xml version="1.0" encoding="utf-8"?>
<project xmlns="http://www.plcopen.org/xml/tc6_0200">
  <fileHeader companyName="" productName="CODESYS" productVersion="CODESYS V3.5 SP13" creationDateTime="2018-10-16T05:39:03.2621849" />
  <contentHeader name="MQTT" version="1.0.0.0" modificationDateTime="2018-10-16T05:30:41.3271196" organization="Stefan Dreyer" author="Stefan Dreyer">
    <Comment>MQTT Stuff
Using some cool stuff of OSCAT libs.
see oscat.de

more to describe
</Comment>
    <coordinateInfo>
      <fbd>
        <scaling x="1" y="1" />
      </fbd>
      <ld>
        <scaling x="1" y="1" />
      </ld>
      <sfc>
        <scaling x="1" y="1" />
      </sfc>
    </coordinateInfo>
    <addData>
      <data name="http://www.3s-software.com/plcopenxml/projectinformation" handleUnknown="implementation">
        <ProjectInformation>
          <property name="Author" type="string">Stefan Dreyer</property>
          <property name="Company" type="string">Stefan Dreyer</property>
          <property name="DefaultNamespace" type="string">SD_MQTT</property>
          <property name="Description" type="string">MQTT Stuff
Using some cool stuff of OSCAT libs.
see oscat.de

more to describe
</property>
          <property name="DocFormat" type="string">reStructuredText</property>
          <property name="IsEndUserLibrary" type="boolean">false</property>
          <property name="LanguageModelAttribute" type="string">qualified-access-only</property>
          <property name="Placeholder" type="string">SD_MQTT</property>
          <property name="Project" type="string">MQTT</property>
          <property name="Released" type="boolean">false</property>
          <property name="Title" type="string">MQTT</property>
          <property name="Version" type="version">1.0.0.0</property>
          <property name="library-category-list" type="library-category-list" />
        </ProjectInformation>
      </data>
    </addData>
  </contentHeader>
  <types>
    <dataTypes>
      <dataType name="INSERT_SPLIT_RETURN">
        <baseType>
          <enum>
            <values>
              <value name="INSERT_NOT_VALID" value="0" />
              <value name="INSERT_DONE" />
              <value name="INSERT_PENDING" />
              <value name="INSERT_ERROR" />
            </values>
          </enum>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
            <Attributes>
              <Attribute Name="qualified_only" Value="" />
              <Attribute Name="strict" Value="" />
            </Attributes>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>bb4d1531-d91b-43d0-a2e0-94b8e19d747c</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="MESSAGETYPE">
        <baseType>
          <enum>
            <values>
              <value name="CONNECT" value="16#10" />
              <value name="CONNACK" value="16#20" />
              <value name="PUBLISH" value="16#30" />
              <value name="PUBACK" value="16#40" />
              <value name="PUBREC" value="16#50" />
              <value name="PUBREL" value="16#60" />
              <value name="PUBCOMP" value="16#70" />
              <value name="SUBSCRIBE" value="16#80" />
              <value name="SUBACK" value="16#90" />
              <value name="UNSUBSCRIBE" value="16#A0" />
              <value name="UNSUBACK" value="16#B0" />
              <value name="PINGREQ" value="16#C0" />
              <value name="PINGRESP" value="16#D0" />
              <value name="DISCONNECT" value="16#E0" />
            </values>
            <baseType>
              <BYTE />
            </baseType>
          </enum>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>f2b44ef8-0bd0-44af-8bb1-57f4cebd4fde</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="PROG_NUM">
        <baseType>
          <enum>
            <values>
              <value name="Publish" />
              <value name="Subscribe" />
              <value name="ParseIncomming" />
              <value name="MoveBuffer" />
              <value name="ParsePublish" />
              <value name="GetBufferFreePos" />
              <value name="GetSplitTopic" />
              <value name="DESTROY_HANDLE_MQTT" />
              <value name="DESTROY_SPLIT_TOPIC" />
              <value name="STATE_MASHINE_IN" />
              <value name="STATE_MASHINE_OUT" />
              <value name="SendOutData" />
              <value name="SendInData" />
              <value name="SendOutDataInsertTopic" />
              <value name="SendOutDataInsertPayload" />
            </values>
          </enum>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
            <Attributes>
              <Attribute Name="qualified_only" Value="" />
              <Attribute Name="strict" Value="" />
            </Attributes>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>c96a8249-695b-4b97-a93f-d9c79b7ceae9</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="QoS">
        <baseType>
          <enum>
            <values>
              <value name="AtMostOnce" value="2#0" />
              <value name="AtLeastOnce" value="2#1" />
              <value name="ExactlyOnce" value="2#10" />
              <value name="Fail" value="2#10000000" />
            </values>
            <baseType>
              <BYTE />
            </baseType>
          </enum>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>dc0ab29a-e4c9-4251-b775-e8f4fc8a2ed4</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="STEPS_IN">
        <baseType>
          <enum>
            <values>
              <value name="WAIT_DATA" value="0" />
              <value name="SEND_PUBACK" />
              <value name="SEND_PUBREC" />
              <value name="WAIT_PUBREL" />
              <value name="SEND_PUBCOMP" />
            </values>
          </enum>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
            <Attributes>
              <Attribute Name="qualified_only" Value="" />
              <Attribute Name="strict" Value="" />
            </Attributes>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>62f118e5-0ccc-4d99-91e8-1c5458854c9a</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="STEPS_OUT">
        <baseType>
          <enum>
            <values>
              <value name="WAIT_DATA" value="0" />
              <value name="SEND_PUBLSIH" />
              <value name="WAIT_PUBREC" />
              <value name="SEND_PUBREL" />
              <value name="WAIT_PUBCOMP" />
              <value name="WAIT_PUBACK" />
              <value name="WAIT_PINGRESP" />
              <value name="SEND_SUBSCRIBE" />
              <value name="WAIT_SUBACK" />
              <value name="SEND_UNSUBSCRIBE" />
              <value name="WAIT_UNSUBACK" />
            </values>
          </enum>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
            <Attributes>
              <Attribute Name="qualified_only" Value="" />
              <Attribute Name="strict" Value="" />
            </Attributes>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>959ee70e-6c1f-4f46-b4d6-2e47c7bb5ec5</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="TOPIC_MATCH">
        <baseType>
          <enum>
            <values>
              <value name="TOPIC_MATCHES" value="1" />
              <value name="TOPIC_DONT_MATCHES" value="2" />
            </values>
            <baseType>
              <BYTE />
            </baseType>
          </enum>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
            <Attributes>
              <Attribute Name="qualified_only" Value="" />
              <Attribute Name="strict" Value="" />
            </Attributes>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>2d2ca9f7-31bc-451a-aac6-7d56f3a3c2f7</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="TOPIC_VALID">
        <baseType>
          <enum>
            <values>
              <value name="TOPIC_UNTESTED" value="0" />
              <value name="TOPIC_VALID" value="2" />
              <value name="TOPIC_NOT_VALID" value="1" />
              <value name="TOPIC_NO_TEST" value="3" />
            </values>
            <baseType>
              <BYTE />
            </baseType>
          </enum>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
            <Attributes>
              <Attribute Name="qualified_only" Value="" />
              <Attribute Name="strict" Value="" />
            </Attributes>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>f7ef1884-ffea-471c-909d-3b229bcf4d4a</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="COM_CONFIG">
        <baseType>
          <struct>
            <variable name="MaxPayloadSize">
              <type>
                <UDINT />
              </type>
              <initialValue>
                <simpleValue value="2000" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">max payload size</xhtml>
              </documentation>
            </variable>
            <variable name="MaxTopicLevels">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="25" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">max topic levels</xhtml>
              </documentation>
            </variable>
            <variable name="MaxTopicElementSize">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="255" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Max Topic elemt size</xhtml>
              </documentation>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>f023999e-09e0-4a7b-bf94-bca33e8956a1</ObjectId>
          </data>
        </addData>
        <documentation>
          <xhtml xmlns="http://www.w3.org/1999/xhtml">here the maximum sizes of paylod and topics are defined
if dynamic low init of split topic is used, don't care about MaxTopicElementSize</xhtml>
        </documentation>
      </dataType>
      <dataType name="DATA_FROM_BROKER">
        <baseType>
          <struct>
            <variable name="MqttTopic">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">use array in size of network buffer to split message dynamic, maybe not ... best is dynamic mammory....
or use an array of Pointer....
or callbacks
 so lets try to buffer public messages and releas one per cycle to application...
now we try dynamic memmory....
MQTT Topic from Broker</xhtml>
              </documentation>
            </variable>
            <variable name="Topics">
              <type>
                <pointer>
                  <baseType>
                    <derived name="SPLIT_TOPIC" />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="MqttPayload">
              <type>
                <pointer>
                  <baseType>
                    <BYTE />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">MQTT Payload for Broker
Payload from broker --&gt; Pointer</xhtml>
              </documentation>
            </variable>
            <variable name="MqttPayloadSize">
              <type>
                <UDINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Payload size</xhtml>
              </documentation>
            </variable>
            <variable name="MessageType">
              <type>
                <derived name="MESSAGETYPE" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">MQTT Message Type</xhtml>
              </documentation>
            </variable>
            <variable name="DataRecived">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Data recived</xhtml>
              </documentation>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>32b50b35-fcff-4e03-852b-c3c9dacef9d9</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="DATA_TO_BROKER">
        <baseType>
          <struct>
            <variable name="PaketData">
              <type>
                <derived name="PAKET_DATA" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Data of Paket</xhtml>
              </documentation>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>8f262079-4448-4ad4-914c-e723074c16c8</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="MQTT_COM">
        <baseType>
          <struct>
            <variable name="S_BUF">
              <type>
                <derived name="NETWORK_BUFFER" />
              </type>
            </variable>
            <variable name="R_BUF">
              <type>
                <derived name="NETWORK_BUFFER" />
              </type>
            </variable>
            <variable name="MQTT_CON">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">if falling edge close with disconnect packet</xhtml>
              </documentation>
            </variable>
            <variable name="MQTT_ABORT">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">if using this to disconnect, don't send disconnect paket....</xhtml>
              </documentation>
            </variable>
            <variable name="MQTT_URL">
              <type>
                <string length="OSCAT_BASIC.STRING_LENGTH" />
              </type>
            </variable>
            <variable name="MQTT_PACKET_NO">
              <type>
                <WORD />
              </type>
            </variable>
            <variable name="TIMEOUT">
              <type>
                <TIME />
              </type>
            </variable>
            <variable name="TLS">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">DNS_IP4 : DWORD;
set to true if you want to use TLS</xhtml>
              </documentation>
            </variable>
            <variable name="TLS_CONFIG">
              <type>
                <pointer>
                  <baseType>
                    <derived name="CommonTypesAndFunctions.TLS_CONFIG" />
                  </baseType>
                </pointer>
              </type>
              <initialValue>
                <simpleValue value="0" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">data to TLS stuff</xhtml>
              </documentation>
            </variable>
            <variable name="MQTT_RCV_STATE">
              <type>
                <BYTE />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">
	0= non
	1= recived
	2= error</xhtml>
              </documentation>
            </variable>
            <variable name="ERROR_C">
              <type>
                <DWORD />
              </type>
            </variable>
            <variable name="ERROR_T">
              <type>
                <BYTE />
              </type>
            </variable>
            <variable name="CLIENT_ID">
              <type>
                <string length="23" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">CONNECT_TO_LOCALHOST:BOOL;</xhtml>
              </documentation>
            </variable>
            <variable name="CLIENT_WILL_TOPIC">
              <type>
                <string length="255" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Topic vof will message after client id</xhtml>
              </documentation>
            </variable>
            <variable name="CLIENT_WILL_MESSAGE_DEAD">
              <type>
                <string length="255" />
              </type>
            </variable>
            <variable name="CLIENT_WILL_RETAIN">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="TRUE" />
              </initialValue>
            </variable>
            <variable name="BROKER_USER">
              <type>
                <string length="254" />
              </type>
            </variable>
            <variable name="BROKER_PASSWORD">
              <type>
                <string length="254" />
              </type>
            </variable>
            <variable name="MQTT_NO_AWNSER">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">pakte wihout request-- return to recivestate 1</xhtml>
              </documentation>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>5209abac-a19a-4b19-a65e-8a7aaacdb271</ObjectId>
          </data>
        </addData>
        <documentation>
          <xhtml xmlns="http://www.w3.org/1999/xhtml">contro struct between HANDLE_MQTT and MQTT_CONTROL</xhtml>
        </documentation>
      </dataType>
      <dataType name="MQTT_IN_DATA">
        <baseType>
          <struct>
            <variable name="step">
              <type>
                <derived name="STEPS_IN" />
              </type>
            </variable>
            <variable name="PaketID">
              <type>
                <WORD />
              </type>
            </variable>
            <variable name="WaitsForBuffFree">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="TimeOut">
              <type>
                <derived name="ton" />
              </type>
            </variable>
            <variable name="TimeOutStarted">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="PUBLISHOrder">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="PUBCOMPOrder">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="QoS">
              <type>
                <derived name="QoS" />
              </type>
            </variable>
            <variable name="CountPubrecRepeat">
              <type>
                <UINT />
              </type>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>4c7c1bae-e8c3-425f-ac0b-be3e1bb059c6</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="MQTT_IN_OUT">
        <baseType>
          <struct>
            <variable name="handleFB">
              <type>
                <pointer>
                  <baseType>
                    <derived name="HANDLE_MQTT" />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">pointer to handle FB</xhtml>
              </documentation>
            </variable>
            <variable name="In">
              <type>
                <pointer>
                  <baseType>
                    <derived name="PAKET_DATA" />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="InFree">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="TRUE" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">in free true if free</xhtml>
              </documentation>
            </variable>
            <variable name="TDI">
              <type>
                <derived name="CommonTypesAndFunctions.TIME_DATE_IMPULS_DATA" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">time, date, impulse...</xhtml>
              </documentation>
            </variable>
            <variable name="TLS_CONFIG">
              <type>
                <pointer>
                  <baseType>
                    <derived name="CommonTypesAndFunctions.TLS_CONFIG" />
                  </baseType>
                </pointer>
              </type>
              <initialValue>
                <simpleValue value="0" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">TLS stuff data</xhtml>
              </documentation>
            </variable>
            <variable name="OUT">
              <type>
                <derived name="DATA_FROM_BROKER" />
              </type>
            </variable>
            <variable name="BROKER_CONNECTED">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="FB_NO_AUTO">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="FB_NO_AUTO_COUNT">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">FBs count</xhtml>
              </documentation>
            </variable>
            <variable name="FB_NO_AUTO_TOKEN">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="1" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">FB Token</xhtml>
              </documentation>
            </variable>
            <variable name="COM_CONFIG">
              <type>
                <derived name="COM_CONFIG" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">config for boot up</xhtml>
              </documentation>
            </variable>
            <variable name="ClientID">
              <type>
                <string length="23" />
              </type>
              <initialValue>
                <simpleValue value="'CODESYS_MQTT'" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">client ID, only chars 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	System never can be anonymos
	</xhtml>
              </documentation>
            </variable>
            <variable name="WillTopicBase">
              <type>
                <string length="255" />
              </type>
              <initialValue>
                <simpleValue value="'MQTTWill'" />
              </initialValue>
            </variable>
            <variable name="ClientWillTopic">
              <type>
                <string length="30" />
              </type>
              <initialValue>
                <simpleValue value="'DEAD'" />
              </initialValue>
            </variable>
            <variable name="ClientWillMessage">
              <type>
                <string length="30" />
              </type>
              <initialValue>
                <simpleValue value="'DIED'" />
              </initialValue>
            </variable>
            <variable name="dynMemUsage">
              <type>
                <UDINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">usage of dynamic RAM</xhtml>
              </documentation>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>55008e55-a327-4545-aaa7-3221c41bb9e1</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="MQTT_INFO">
        <baseType>
          <struct>
            <variable name="MQTT_CONNECTED">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="MQTT_ERROR">
              <type>
                <string length="OSCAT_BASIC.STRING_LENGTH" />
              </type>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>32a39fb8-f516-444c-be3c-83354e376270</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="MQTT_OUT_DATA">
        <baseType>
          <struct>
            <variable name="InDataFromFb">
              <type>
                <pointer>
                  <baseType>
                    <derived name="PAKET_DATA" />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="step">
              <type>
                <derived name="STEPS_OUT" />
              </type>
            </variable>
            <variable name="WaitsForBuffFree">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="PUBRECOrder">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="TimeOut">
              <type>
                <derived name="ton" />
              </type>
            </variable>
            <variable name="TimeOutStarted">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="PUBLISHOrder">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="PUBRELRepeatCounter">
              <type>
                <UINT />
              </type>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>ae326562-56be-495d-a72e-4a01b53e8ece</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="PAKET_DATA">
        <baseType>
          <struct>
            <variable name="MqttTopic">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">MQTT Topic for Broker</xhtml>
              </documentation>
            </variable>
            <variable name="MqttTopicLength">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Topic length</xhtml>
              </documentation>
            </variable>
            <variable name="MqttPayload">
              <type>
                <pointer>
                  <baseType>
                    <BYTE />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">MQTT Payload for Broker</xhtml>
              </documentation>
            </variable>
            <variable name="MqttPayloadLength">
              <type>
                <UDINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Payload length</xhtml>
              </documentation>
            </variable>
            <variable name="MessageType">
              <type>
                <derived name="MESSAGETYPE" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">MQTT Message Type</xhtml>
              </documentation>
            </variable>
            <variable name="MessageQoS">
              <type>
                <derived name="QoS" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">MQTT QoS</xhtml>
              </documentation>
            </variable>
            <variable name="SubackQoS">
              <type>
                <derived name="QoS" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">SUCACK QoS Response</xhtml>
              </documentation>
            </variable>
            <variable name="MessageRetain">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">MQTT reatin</xhtml>
              </documentation>
            </variable>
            <variable name="DUP">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Retry of paket</xhtml>
              </documentation>
            </variable>
            <variable name="PaketId">
              <type>
                <WORD />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">PakatID for header</xhtml>
              </documentation>
            </variable>
            <variable name="FbId">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">ID of MQTT FB to store or of request to Broker</xhtml>
              </documentation>
            </variable>
            <variable name="SendSucsess">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Send was succsessfull</xhtml>
              </documentation>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>562b289a-9159-4417-8182-cc4e81b366b8</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="RECIVE_PAKET">
        <baseType>
          <struct>
            <variable name="MqttTopic">
              <type>
                <string length="2000" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">MQTT Topic</xhtml>
              </documentation>
            </variable>
            <variable name="MqttPayload">
              <type>
                <string length="2000" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">MQTT Payload</xhtml>
              </documentation>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>5ccc79d7-9560-4034-9035-9d8c8e8be5c7</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="REMAINING_LENGTH_RETURN">
        <baseType>
          <struct>
            <variable name="RemainingLength">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="IndexAfterRemainingLength">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="Error">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="BuffToSmall">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">not all bytes of remaining length in buffer...</xhtml>
              </documentation>
            </variable>
            <variable name="SizeRemainingLength">
              <type>
                <USINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">size of remaining length</xhtml>
              </documentation>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>94c78556-e4a3-4405-aebc-1e66657239c5</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="SEND_INFOS">
        <baseType>
          <struct>
            <variable name="SubscribeIndex">
              <type>
                <INT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">this index is to be subscribed</xhtml>
              </documentation>
            </variable>
            <variable name="SubscribeNeeded">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="FALSE" />
              </initialValue>
            </variable>
            <variable name="SubscribeBlocking">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="UnsubscribeIndex">
              <type>
                <INT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">this index is to be subscribed</xhtml>
              </documentation>
            </variable>
            <variable name="UnsubscribeNeeded">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="FALSE" />
              </initialValue>
            </variable>
            <variable name="UnsubscribeBlocking">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="PublishBlocking">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">this index is to be published
	PublishIndex:INT;
	PublishNeeded:BOOL := FALSE;</xhtml>
              </documentation>
            </variable>
            <variable name="PublishBlockingIndex">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="PingIndex">
              <type>
                <INT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">this index is to be published
	PubrelIndex:INT;
	PubrelNeeded:BOOL := FALSE;</xhtml>
              </documentation>
            </variable>
            <variable name="PingNeeded">
              <type>
                <BOOL />
              </type>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>2bc87a2f-4743-4048-b61f-7cca24bbfb38</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="SPLIT_TOPIC">
        <baseType>
          <struct>
            <variable name="Topics">
              <type>
                <pointer>
                  <baseType>
                    <pointer>
                      <baseType>
                        <string />
                      </baseType>
                    </pointer>
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">this is going to be a pointer to a array of pointer to stings  </xhtml>
              </documentation>
            </variable>
            <variable name="ValidFields">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">count of vailid fields in the array</xhtml>
              </documentation>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>093130aa-4b04-4d26-9869-e5698edc6583</ObjectId>
          </data>
        </addData>
      </dataType>
    </dataTypes>
    <pous>
      <pou name="Doku" pouType="program">
        <interface />
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">(*

Hello There,

with this library you are able to send and recvice MQTT paket on all QoS levels 0-2.

Use Pubish to publish data(Strings and binary),

Use subscribe to recive MQTT data. On Subscribe you can tell the FB if you are expecting an String as data, so you will get one on the pointer output.

How to use you can see in the example and testCase FB. This is my Test Case an it does up to 100 send and recives per second on an raspberry PI 1+ connectet to an mosquitto broker on an 
windows 10 maschine.

If you find errors, or anny instability, tell me, i will have a look.

TLS works fine without certificates.

This Projekt i using some parts of the grat OSCAT libs, so take a look at oscat.de

Greatings 

*)</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>19d5ffa0-ed0e-45b0-9ceb-9920b74e90c1</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="TestOutOfTheBoxNoTLS" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="client">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'test.mosquitto.org:1883'" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">test.mosquitto.org</xhtml>
              </documentation>
            </variable>
          </inputVars>
          <localVars>
            <variable name="MQTTClient">
              <type>
                <derived name="HANDLE_MQTT" />
              </type>
            </variable>
            <variable name="MQTT_IN_OUT">
              <type>
                <derived name="MQTT_IN_OUT" />
              </type>
            </variable>
            <variable name="MQTTInfo">
              <type>
                <derived name="MQTT_INFO" />
              </type>
            </variable>
            <variable name="publish">
              <type>
                <derived name="MQTTPublish" />
              </type>
            </variable>
            <variable name="subscribe">
              <type>
                <derived name="MQTTSubscribe" />
              </type>
            </variable>
            <variable name="ReciveSubscribeTopic">
              <type>
                <string length="255" />
              </type>
            </variable>
            <variable name="ReciveSubscribePayload">
              <type>
                <string length="255" />
              </type>
            </variable>
            <variable name="State">
              <type>
                <derived name="MQTTState" />
              </type>
            </variable>
            <variable name="init">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="varSend">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="timerSend">
              <type>
                <derived name="ton" />
              </type>
            </variable>
            <variable name="Payload">
              <type>
                <string />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">IF NOT init THEN
	init := TRUE;
	MQTT_IN_OUT.ClientID := CONCAT('CodesysMqtt',TO_STRING(TICKS.GetTick(xDummy:= TRUE)));
	publish.SetMqttInOut(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
	subscribe.SetMqttInOut(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
	
	State.Init(
	State:= ADR(varSend), 
	Topic:= ADR('CODESYS-MQTT-BY-SD/State'), 
	StateName:= ADR(''), 
	StateValueOn:= ADR('On'), 
	StateValueOff:= ADR('Off'), 
	MQTT_IN_OUT:= ADR(MQTT_IN_OUT), 
	QoS:= QoS.ExactlyOnce, 
	RetainMqtt:= TRUE);
END_IF
timerSend(in := NOT varSend, PT := T#2S);
varSend := timerSend.Q; 
MQTTClient(
	MQTT_INFO:= MQTTInfo, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= TRUE, 
	URL:= client, 
	TIMEOUT:= T#5S, 
	TLS:= FALSE);
Payload:= TO_STRING(TICKS.GetTick(xDummy:= TRUE));

publish(
	Topic:= ADR('CODESYS-MQTT-BY-SD/Tick'), 
	PayloadString:= ADR(Payload), 
	PublishAsString:= TRUE, 
	QoSIn:= QoS.ExactlyOnce, 
	MRetain:= TRUE, 
	send:= varSend);
	
subscribe(
	Subscribe:= TRUE, 
	Topic:= ADR('CODESYS-MQTT-BY-SD/Tick'), 
	QoSSubscribe:= QoS.ExactlyOnce, 
	ExpectingString:= TRUE);

IF subscribe.Recived THEN
	ReciveSubscribePayload := subscribe.PayloadString^;
	ReciveSubscribeTopic := subscribe.TopicOut^;
END_IF


State();</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>7710ce00-c1ae-47be-931d-77aa31d80969</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="TestOutOfTheBoxTLS" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="client">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'test.mosquitto.org:8883'" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">test.mosquitto.org</xhtml>
              </documentation>
            </variable>
          </inputVars>
          <localVars>
            <variable name="MQTTClient">
              <type>
                <derived name="HANDLE_MQTT" />
              </type>
            </variable>
            <variable name="MQTT_IN_OUT">
              <type>
                <derived name="MQTT_IN_OUT" />
              </type>
            </variable>
            <variable name="MQTTInfo">
              <type>
                <derived name="MQTT_INFO" />
              </type>
            </variable>
            <variable name="publish">
              <type>
                <derived name="MQTTPublish" />
              </type>
            </variable>
            <variable name="subscribe">
              <type>
                <derived name="MQTTSubscribe" />
              </type>
            </variable>
            <variable name="ReciveSubscribeTopic">
              <type>
                <string length="255" />
              </type>
            </variable>
            <variable name="ReciveSubscribePayload">
              <type>
                <string length="255" />
              </type>
            </variable>
            <variable name="State">
              <type>
                <derived name="MQTTState" />
              </type>
            </variable>
            <variable name="init">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="varSend">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="timerSend">
              <type>
                <derived name="ton" />
              </type>
            </variable>
            <variable name="Payload">
              <type>
                <string />
              </type>
            </variable>
            <variable name="TLS_CONFIG">
              <type>
                <derived name="CommonTypesAndFunctions.TLS_CONFIG" />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">IF NOT init THEN
	init := TRUE;
	MQTT_IN_OUT.ClientID := CONCAT('CodesysMqtt',TO_STRING(TICKS.GetTick(xDummy:= TRUE)));
	publish.SetMqttInOut(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
	subscribe.SetMqttInOut(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
	State.Init(
	State:= ADR(varSend), 
	Topic:= ADR('CODESYS-MQTT-BY-SD/State'), 
	StateName:= ADR(''), 
	StateValueOn:= ADR('On'), 
	StateValueOff:= ADR('Off'), 
	MQTT_IN_OUT:= ADR(MQTT_IN_OUT), 
	QoS:= QoS.ExactlyOnce, 
	RetainMqtt:= TRUE);
	MQTT_IN_OUT.TLS_CONFIG := ADR(TLS_CONFIG);
END_IF
timerSend(in := NOT varSend, PT := T#2S);
varSend := timerSend.Q; 
MQTTClient(
	MQTT_INFO:= MQTTInfo, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= TRUE, 
	URL:= client, 
	TIMEOUT:= T#5S, 
	TLS:= TRUE);
Payload:= TO_STRING(TICKS.GetTick(xDummy:= TRUE));

publish(
	Topic:= ADR('CODESYS-MQTT-BY-SD/Tick'), 
	PayloadString:= ADR(Payload), 
	PublishAsString:= TRUE, 
	QoSIn:= QoS.ExactlyOnce, 
	MRetain:= TRUE, 
	send:= varSend);
	
subscribe(
	Subscribe:= TRUE, 
	Topic:= ADR('CODESYS-MQTT-BY-SD/Tick'), 
	QoSSubscribe:= QoS.ExactlyOnce, 
	ExpectingString:= TRUE);

IF subscribe.Recived THEN
	ReciveSubscribePayload := subscribe.PayloadString^;
	ReciveSubscribeTopic := subscribe.TopicOut^;
END_IF


State();</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>2f0f42d5-f5e7-4150-9177-534c70b72865</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="CheckTopicLevel" pouType="function">
        <interface>
          <returnType>
            <BOOL />
          </returnType>
          <inputVars>
            <variable name="s1">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">String from Broker</xhtml>
              </documentation>
            </variable>
            <variable name="s2">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Subscribe String</xhtml>
              </documentation>
            </variable>
          </inputVars>
          <localVars>
            <variable name="LenS1">
              <type>
                <UINT />
              </type>
            </variable>
          </localVars>
          <documentation>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">true if levels the same</xhtml>
          </documentation>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">CheckTopicLevel := FALSE;
//test Wildcard
IF (s2^[0] = CommonTypesAndFunctions.GetChar(in:= '+')) THEN //(s2[0] = GetChar(in:= '#')) OR  don't check # here
	CheckTopicLevel := TRUE;
	RETURN;	
END_IF
LenS1 := CommonTypesAndFunctions.len(STR:= s1); 
IF (LenS1 &lt;&gt; CommonTypesAndFunctions.len(STR:= s2)) THEN 
	RETURN;
END_IF//if len not eval then return
IF (CommonTypesAndFunctions.find(STR1:= s1, STR2:= s2) &gt;= 0) OR (LenS1 = 0)THEN
	CheckTopicLevel := TRUE;
END_IF</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>655f312f-4e19-41ff-9a48-b9cd257567fd</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="DoRemainingLength" pouType="function">
        <interface>
          <returnType>
            <USINT />
          </returnType>
          <inputVars>
            <variable name="buffer">
              <type>
                <pointer>
                  <baseType>
                    <BYTE />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="RemainingLength">
              <type>
                <UINT />
              </type>
            </variable>
          </inputVars>
          <localVars>
            <variable name="LocalLength">
              <type>
                <LINT />
              </type>
            </variable>
            <variable name="LocalBuffer">
              <type>
                <array>
                  <dimension lower="0" upper="3" />
                  <baseType>
                    <BYTE />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="BufferIndex">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="0" />
              </initialValue>
            </variable>
            <variable name="TmpByte">
              <type>
                <BYTE />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">//check if we have to move data for inserting remaining length
//borders are given in the mqtt doku
//
IF RemainingLength &lt;= 128 THEN
	buffer[1] := UINT_TO_BYTE(RemainingLength);
	DoRemainingLength := 0;
ELSE
	LocalLength := RemainingLength;
	REPEAT
		TmpByte := LINT_TO_BYTE(LocalLength MOD 128);
		LocalLength := LocalLength / 128;
		IF LocalLength &gt; 0 THEN
			TmpByte := TmpByte OR 128;
		END_IF
		LocalBuffer[BufferIndex] := TmpByte; 
		BufferIndex := BufferIndex +1;
	UNTIL 
		LocalLength &lt;= 0 
	END_REPEAT
	//now move mem	
	//buffer index points to NEXT field, so sub 1
	MEM.MemMove(pSource:= buffer+2, pDestination:= buffer + 2 + BufferIndex - 1 , uiNumberOfBytes:= RemainingLength);
	CASE BufferIndex OF
		2: 	buffer[1]:= LocalBuffer[0];
			buffer[2]:= LocalBuffer[1];
			DoRemainingLength := 1;
		3:	buffer[1]:= LocalBuffer[0];
			buffer[2]:= LocalBuffer[1];
			buffer[3]:= LocalBuffer[2];
			DoRemainingLength := 2;
		4:	buffer[1]:= LocalBuffer[0];
			buffer[2]:= LocalBuffer[1];
			buffer[3]:= LocalBuffer[2];
			buffer[4]:= LocalBuffer[3];
			DoRemainingLength := 3;
		
	END_CASE
	
END_IF
</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>e2e73127-c450-4db7-8e16-8119af21d884</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="DoRemainingLengthBevor" pouType="function">
        <interface>
          <returnType>
            <USINT />
          </returnType>
          <inputVars>
            <variable name="buffer">
              <type>
                <pointer>
                  <baseType>
                    <BYTE />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">points to start of buffer, not to start of remainig length!</xhtml>
              </documentation>
            </variable>
            <variable name="SizeTopic">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="SizePayload">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="InQoS">
              <type>
                <derived name="QoS" />
              </type>
            </variable>
          </inputVars>
          <localVars>
            <variable name="RemainingLength">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="LocalLength">
              <type>
                <LINT />
              </type>
            </variable>
            <variable name="LocalBuffer">
              <type>
                <array>
                  <dimension lower="0" upper="3" />
                  <baseType>
                    <BYTE />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="BufferIndex">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="0" />
              </initialValue>
            </variable>
            <variable name="TmpByte">
              <type>
                <BYTE />
              </type>
            </variable>
          </localVars>
          <documentation>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">here no move of data, cal remainig length bevor moving topic and paylod, use this for 
borders are given in the mqtt doku
use this for publish pakets</xhtml>
          </documentation>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">
	
RemainingLength := SizeTopic + SizePayload;
	
RemainingLength := RemainingLength + 2;//add topic size encoding space
IF NOT (InQoS = QoS.AtMostOnce) THEN
	RemainingLength := RemainingLength + 2;//add space for paket identifier
END_IF

IF RemainingLength &lt;= 128 THEN
	buffer[1] := UDINT_TO_BYTE(RemainingLength);
	DoRemainingLengthBevor := 0;
ELSE
	LocalLength := RemainingLength;
	REPEAT
		TmpByte := LINT_TO_BYTE(LocalLength MOD 128);
		LocalLength := LocalLength / 128;
		IF LocalLength &gt; 0 THEN
			TmpByte := TmpByte OR 128;
		END_IF
		LocalBuffer[BufferIndex] := TmpByte; 
		BufferIndex := BufferIndex +1;
	UNTIL 
		LocalLength &lt;= 0 
	END_REPEAT
	CASE BufferIndex OF
		2: 	buffer[1]:= LocalBuffer[0];
			buffer[2]:= LocalBuffer[1];
			DoRemainingLengthBevor := 1;
		3:	buffer[1]:= LocalBuffer[0];
			buffer[2]:= LocalBuffer[1];
			buffer[3]:= LocalBuffer[2];
			DoRemainingLengthBevor := 2;
		4:	buffer[1]:= LocalBuffer[0];
			buffer[2]:= LocalBuffer[1];
			buffer[3]:= LocalBuffer[2];
			buffer[4]:= LocalBuffer[3];
			DoRemainingLengthBevor := 3;
		
	END_CASE
	
END_IF
</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>7a7085eb-fade-40fb-a106-1b3f7da54eb0</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="GetRemainingLength" pouType="function">
        <interface>
          <returnType>
            <derived name="REMAINING_LENGTH_RETURN" />
          </returnType>
          <inputVars>
            <variable name="Buff">
              <type>
                <pointer>
                  <baseType>
                    <BYTE />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Pointer to Buffer</xhtml>
              </documentation>
            </variable>
            <variable name="pos">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Start of data in Buffer</xhtml>
              </documentation>
            </variable>
            <variable name="BuffSize">
              <type>
                <UDINT />
              </type>
            </variable>
          </inputVars>
          <localVars>
            <variable name="BufferIndex">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="1" />
              </initialValue>
            </variable>
            <variable name="Multipler">
              <type>
                <UDINT />
              </type>
              <initialValue>
                <simpleValue value="1" />
              </initialValue>
            </variable>
            <variable name="TmpByte">
              <type>
                <BYTE />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">GetRemainingLength.Error := FALSE;
GetRemainingLength.SizeRemainingLength:= 0;

GetRemainingLength.Error := FALSE;
BufferIndex := pos + 1;
REPEAT
	IF BufferIndex &gt; (BuffSize - 1) THEN
		GetRemainingLength.BuffToSmall := TRUE;
	ELSE
		TmpByte := Buff[BufferIndex];
		BufferIndex := BufferIndex + 1;
		GetRemainingLength.RemainingLength := GetRemainingLength.RemainingLength + (TmpByte AND 127) * Multipler;
		Multipler := Multipler *128;
		IF Multipler &gt; 128*128*128 THEN
			GetRemainingLength.RemainingLength := 0;//lengt 0 if broken
			GetRemainingLength.Error := TRUE;
		END_IF
	END_IF
	GetRemainingLength.SizeRemainingLength := GetRemainingLength.SizeRemainingLength + 1;
UNTIL
	(TmpByte AND 128) = 0 OR GetRemainingLength.RemainingLength = 0 OR GetRemainingLength.BuffToSmall
END_REPEAT
GetRemainingLength.IndexAfterRemainingLength := BufferIndex;</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>168ed935-d7fd-4c44-93c7-2a8614b8ecf9</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="InsertStringToBufferAndLength" pouType="function">
        <interface>
          <returnType>
            <UINT />
          </returnType>
          <inputVars>
            <variable name="Str">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="buff">
              <type>
                <pointer>
                  <baseType>
                    <BYTE />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">address to buffer</xhtml>
              </documentation>
            </variable>
            <variable name="pos">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Start to insert</xhtml>
              </documentation>
            </variable>
          </inputVars>
          <localVars>
            <variable name="length">
              <type>
                <UINT />
              </type>
            </variable>
          </localVars>
          <documentation>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">returnds new pos in buff</xhtml>
          </documentation>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">length := CommonTypesAndFunctions.LEN(Str);
buff[pos]:= OSCAT_BASIC.BYTE_OF_DWORD(in:= length, N:= 1);
buff[pos+1]:= OSCAT_BASIC.BYTE_OF_DWORD(in:= length, N:= 0);

MEM.MemMove(pSource:= str, pDestination:= ADR(buff[pos+2]), uiNumberOfBytes:= length);
InsertStringToBufferAndLength := pos + length + 2;</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>ed441082-1d3e-463c-bc84-a704e7534de7</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="HANDLE_MQTT" pouType="functionBlock">
        <interface>
          <inOutVars>
            <variable name="MQTT_INFO">
              <type>
                <derived name="MQTT_INFO" />
              </type>
            </variable>
            <variable name="MQTT_IN_OUT">
              <type>
                <derived name="MQTT_IN_OUT" />
              </type>
            </variable>
          </inOutVars>
          <inputVars>
            <variable name="ENABLE">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="URL">
              <type>
                <string length="OSCAT_BASIC.STRING_LENGTH" />
              </type>
            </variable>
            <variable name="TIMEOUT">
              <type>
                <TIME />
              </type>
            </variable>
            <variable name="TLS">
              <type>
                <BOOL />
              </type>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="ERROR_C">
              <type>
                <DWORD />
              </type>
            </variable>
            <variable name="ERROR_T">
              <type>
                <BYTE />
              </type>
            </variable>
          </outputVars>
          <localVars>
            <variable name="DT_MQTT">
              <type>
                <derived name="CommonTypesAndFunctions.TIME_DATE_IMPULS" />
              </type>
            </variable>
            <variable name="MQTT_CONTROL">
              <type>
                <derived name="MQTT_CONTROL" />
              </type>
            </variable>
            <variable name="step">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="i1">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="PingSlot">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="COM">
              <type>
                <derived name="MQTT_COM" />
              </type>
            </variable>
            <variable name="TmpString">
              <type>
                <string length="255" />
              </type>
            </variable>
            <variable name="TimeoutConnection">
              <type>
                <derived name="TON" />
              </type>
            </variable>
            <variable name="MqttsDoneIo">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="CycleTime">
              <type>
                <DWORD />
              </type>
            </variable>
            <variable name="LastCycleTime">
              <type>
                <DWORD />
              </type>
            </variable>
            <variable name="NextPingTime">
              <type>
                <derived name="CAA.TICK" />
              </type>
            </variable>
            <variable name="PingTime">
              <type>
                <derived name="CAA.TICK" />
              </type>
              <initialValue>
                <simpleValue value="((MyConstants.KEEP_ALIVE_TIME * 1000) - 6000)" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">next ping after 6 seconds </xhtml>
              </documentation>
            </variable>
            <variable name="PingRequestet">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Ping was sendet</xhtml>
              </documentation>
            </variable>
            <variable name="PingData">
              <type>
                <derived name="DATA_TO_BROKER" />
              </type>
            </variable>
            <variable name="myFbNo">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="PubrelOrderIndexCounter">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="PubcompOrderIndexCounter">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="LogFile">
              <type>
                <derived name="CAA.HANDLE" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">log file</xhtml>
              </documentation>
            </variable>
            <variable name="open">
              <type>
                <derived name="FILE.Open" />
              </type>
            </variable>
            <variable name="write">
              <type>
                <derived name="FILE.Write" />
              </type>
            </variable>
            <variable name="LogString">
              <type>
                <string length="255" />
              </type>
            </variable>
            <variable name="DebugFile">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="FALSE" />
              </initialValue>
            </variable>
            <variable name="OutData">
              <type>
                <array>
                  <dimension lower="0" upper="QoS_BUFFER_SIZE" />
                  <baseType>
                    <derived name="MQTT_OUT_DATA" />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="InData">
              <type>
                <array>
                  <dimension lower="0" upper="QoS_BUFFER_SIZE" />
                  <baseType>
                    <derived name="MQTT_IN_DATA" />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="PublishSendListCount">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="PublishSendList">
              <type>
                <array>
                  <dimension lower="0" upper="QoS_BUFFER_SIZE" />
                  <baseType>
                    <INT />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="PubrelSendListCount">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="PubrelSendList">
              <type>
                <array>
                  <dimension lower="0" upper="QoS_BUFFER_SIZE" />
                  <baseType>
                    <INT />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="PubackSendListCount">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="PubackSendList">
              <type>
                <array>
                  <dimension lower="0" upper="QoS_BUFFER_SIZE" />
                  <baseType>
                    <INT />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="PubrecSendListCount">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="PubrecSendList">
              <type>
                <array>
                  <dimension lower="0" upper="QoS_BUFFER_SIZE" />
                  <baseType>
                    <INT />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="PubcompSendListCount">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="PubcompSendList">
              <type>
                <array>
                  <dimension lower="0" upper="QoS_BUFFER_SIZE" />
                  <baseType>
                    <INT />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="RepeatedPublish">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Repeted Publishs</xhtml>
              </documentation>
            </variable>
            <variable name="RepeatedPublishsAfterPubrel">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Repeatet publishs afert ot much repeat of pubrel</xhtml>
              </documentation>
            </variable>
            <variable name="RepeatedPubrel">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Repeted pubrel</xhtml>
              </documentation>
            </variable>
            <variable name="CountRepeatedPing">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Repeted Ping</xhtml>
              </documentation>
            </variable>
            <variable name="CountRepeatedPingDisconnect">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Repeated pings untill disconnect</xhtml>
              </documentation>
            </variable>
            <variable name="Publishsunacknowledged">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">count of Publishs unacknowledged</xhtml>
              </documentation>
            </variable>
            <variable name="LastToBigTopic">
              <type>
                <string length="255" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">last part of 255 chars of to big paket topic</xhtml>
              </documentation>
            </variable>
            <variable name="CountToBigTopics">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">count of to big topics</xhtml>
              </documentation>
            </variable>
            <variable name="CountLengthErrors">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Cont of ength Error Pakets</xhtml>
              </documentation>
            </variable>
            <variable name="CountRepeatPublishRecive">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Count of repeatet publishs</xhtml>
              </documentation>
            </variable>
            <variable name="CountRecivedPublishs">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Count Recived Publishs</xhtml>
              </documentation>
            </variable>
            <variable name="CountSendedPublishs">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">count sended publishs</xhtml>
              </documentation>
            </variable>
            <variable name="CountRepeatSubscribe">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Count of repeated subscribs</xhtml>
              </documentation>
            </variable>
            <variable name="CountRepeatUnsubscribe">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Count of repeated unsubscribs</xhtml>
              </documentation>
            </variable>
            <variable name="CountRepeatetPubrec">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Count of repeatet pubrec</xhtml>
              </documentation>
            </variable>
            <variable name="PUBREC_ERROR_ID_BUFFER">
              <type>
                <array>
                  <dimension lower="0" upper="(PUBREC_ERROR_ID_BUFFER_SIZE - 1)" />
                  <baseType>
                    <UINT />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="PUBREC_ERROR_INDEX">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="OutgoingPublishOrderIndexCounter">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">send Publish order Index</xhtml>
              </documentation>
            </variable>
            <variable name="IncomingPublishOrderIndexCounter">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">recive Publish order Index</xhtml>
              </documentation>
            </variable>
            <variable name="CountRecivePubrelUnknown">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Recived Pubrel, Paket not found</xhtml>
              </documentation>
            </variable>
            <variable name="CountReciveUnsubackUnknown">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Recived Unsuback, Paket not found</xhtml>
              </documentation>
            </variable>
            <variable name="CountReciveSubackUnknown">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Recived Suback, Paket not found</xhtml>
              </documentation>
            </variable>
            <variable name="CountRecivePubackUnknown">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Recived Puback, Paket not found</xhtml>
              </documentation>
            </variable>
            <variable name="CountRecivePubrecUnknown">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Recived Pubrec, Paket not found</xhtml>
              </documentation>
            </variable>
            <variable name="CountRecivePubcompUnknown">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Recived Pubcomp, Paket not found</xhtml>
              </documentation>
            </variable>
            <variable name="SendInfos">
              <type>
                <derived name="SEND_INFOS" />
              </type>
            </variable>
            <variable name="CountOutSendNotFree">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="CountInSendNotFree">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="CountCantSendPublishBufferToFull">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="CounterPublishSendForMonitor">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="PublishsSendPerSeconde">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="CounterPublishRecivedForMonitor">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="PublishsRecivedPerSeconde">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="NotKnownPaket">
              <type>
                <derived name="MESSAGETYPE" />
              </type>
            </variable>
            <variable name="CountUnkownPaket">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="LastPaktetForUnkownPaket">
              <type>
                <derived name="MESSAGETYPE" />
              </type>
            </variable>
            <variable name="HelperLastPaktetForUnkownPaket">
              <type>
                <derived name="MESSAGETYPE" />
              </type>
            </variable>
            <variable name="CountBufferMoves">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="CountNothingSend">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="CountConnectAttempt">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="CountSplitTopicSizeExceeded">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">count of topic size exceeded</xhtml>
              </documentation>
            </variable>
            <variable name="PublishReciveBuffer">
              <type>
                <array>
                  <dimension lower="0" upper="RECIVE_PUBLISH_BUFFER_SIZE" />
                  <baseType>
                    <BYTE />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="PublishReciveBufferCount">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="PublishReciveBufferCountMax">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="PublishReciveTopicLengt">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="PublishRecivePayloadLengt">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="PublishReciveBufferAssignment">
              <type>
                <UDINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">size of assignment in recive publish buffer</xhtml>
              </documentation>
            </variable>
            <variable name="PublishReciveBufferAssignmentMax">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="PublishReciveBufferCountFull">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="CountWaitForRestOfPaket">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="CountResetBufferIn">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="InBufferMoved">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="SendFree">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="SplitTopic">
              <type>
                <derived name="SplitTopic" />
              </type>
            </variable>
            <variable name="InsertSplitTopic">
              <type>
                <derived name="InsertSplitTopic" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">PublishSplitetd: BOOL;</xhtml>
              </documentation>
            </variable>
            <variable name="InsertSplitPayload">
              <type>
                <derived name="InsertSplitPayload" />
              </type>
            </variable>
            <variable name="StepBuildPublish">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="StepBuildSubscribe">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="StepBuildUnsubscribe">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="SplitPublishBuffer">
              <type>
                <pointer>
                  <baseType>
                    <BYTE />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="SplitPublishBufferSize">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="SplitPublishLength">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="SplitPublishLock">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">output from buffer Don't write new data!</xhtml>
              </documentation>
            </variable>
            <variable name="MaxPublishPacketSize">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="PayloadMemorySize">
              <type>
                <DWORD />
              </type>
            </variable>
            <variable name="TopicMemorySize">
              <type>
                <DWORD />
              </type>
            </variable>
            <variable name="COM_CONFIG">
              <type>
                <derived name="COM_CONFIG" />
              </type>
            </variable>
            <variable name="BufferTopic">
              <type>
                <array>
                  <dimension lower="0" upper="SIZEOF(COM.S_BUF.BUFFER)" />
                  <baseType>
                    <BYTE />
                  </baseType>
                </array>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">doesn't need to be biger than network buffer, </xhtml>
              </documentation>
            </variable>
            <variable name="BufferPayload">
              <type>
                <array>
                  <dimension lower="0" upper="SIZEOF(COM.S_BUF.BUFFER)" />
                  <baseType>
                    <BYTE />
                  </baseType>
                </array>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">because is only used if full paket resits in network buffer</xhtml>
              </documentation>
            </variable>
            <variable name="PublishSplited">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">publish paket broken, waiting for more data</xhtml>
              </documentation>
            </variable>
            <variable name="DoDisconnect">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="SendetBytes">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="RecivedBytes">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="InSlotsWorking">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="OutSlotsWorking">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="DynMemUsagePointer">
              <type>
                <pointer>
                  <baseType>
                    <UDINT />
                  </baseType>
                </pointer>
              </type>
            </variable>
          </localVars>
          <localVars constant="true">
            <variable name="QoS_BUFFER_SIZE">
              <type>
                <INT />
              </type>
              <initialValue>
                <simpleValue value="50" />
              </initialValue>
            </variable>
            <variable name="RECIVE_PUBLISH_BUFFER_SIZE">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="NETWORK_BUFFER_LONG_SIZE" />
              </initialValue>
            </variable>
            <variable name="TRANSMIT_BUFFER_SIZE">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="NETWORK_BUFFER_LONG_SIZE" />
              </initialValue>
            </variable>
            <variable name="SIZE_PUBREL">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="4" />
              </initialValue>
            </variable>
            <variable name="SIZE_UNSUBACK">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="4" />
              </initialValue>
            </variable>
            <variable name="SIZE_PINGRESP">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="2" />
              </initialValue>
            </variable>
            <variable name="SIZE_PINGREQ">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="2" />
              </initialValue>
            </variable>
            <variable name="SIZE_SUBACK">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="5" />
              </initialValue>
            </variable>
            <variable name="SIZE_PUBACK">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="4" />
              </initialValue>
            </variable>
            <variable name="SIZE_PUBREC">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="4" />
              </initialValue>
            </variable>
            <variable name="SIZE_PUBCOMP">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="4" />
              </initialValue>
            </variable>
            <variable name="SIZE_PAKET_BUFFER_HEADER">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="4" />
              </initialValue>
            </variable>
            <variable name="PUBREC_ERROR_ID_BUFFER_SIZE">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="100" />
              </initialValue>
            </variable>
            <variable name="MAX_PING_REPEATS">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="10" />
              </initialValue>
            </variable>
            <variable name="SPLIT_PUBLISH_BUFFER_ADDITIONAL_RAM">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="15" />
              </initialValue>
            </variable>
            <variable name="COUNT_MAX_PUBREC_REPEAT_TO_DISCHARGE">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="20" />
              </initialValue>
            </variable>
          </localVars>
          <documentation>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">
var/log/mosquitto/mosquitto.log
Messsages are not beeing repeatet, if timout for an awnser then connection is cancelde, neu estableshed and de publisher have to start new
Start the command line subscriber:
mosquitto_sub -v -t 'test/topic'
mosquitto_sub -v -h test.mosquitto.org -t 'test/topic'


sudo apt-get install tshark 

tshark -i 1 -a duration:60 -w /tmp/wlan.pcap

debug / logging :
mosquitto_sub -v -t '$SYS/#'
sudo nano /etc/mosquitto/mosquitto.conf  --&gt; 'log_type all'
Publish test message with the command line publisher:
mosquitto_pub -t 'test/topic' -m 'helloWorld'
change check free to InFbNo

kopieren
sudo cp /var/log/mosquitto/mosquitto.log /tmp/
zugriff
sudo chmod -v a=r /tmp/mosquitto.log


TODO: Take care of clean session, is enabled, do it paramable?

layout publish recive buffer:
	prepaerd for Sizese larger 256 byte
	0..1 --&gt; size of topic
	2..x --&gt; topic string
	x+1..x+2 --&gt; size of payload
	x+3..y --&gt; payload 

	recive publish buffer layout:
	0 byte 3 of topic length of udint
	1 byte 2 of topic length of udint
	2 byte 1 of topic length of udint
	3 byte 0 of topic length of udint
	4+n Topic string without termination
	n		byte 3 of payload length of udint
	n+1		byte 2 of payload length of udint
	n+2		byte 1 of payload length of udint
	n+3		byte 0 of payload length of udint
	n+4+x Payload
	
	
	
</xhtml>
          </documentation>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">//first organisize FB nums and FB Tokens...
myFbNo := MQTT_IN_OUT.FB_NO_AUTO + 1;
MQTT_IN_OUT.FB_NO_AUTO_COUNT := myFbNo;
//reset token
IF MQTT_IN_OUT.FB_NO_AUTO_TOKEN &gt;= myFbNo - 1 THEN
	MQTT_IN_OUT.FB_NO_AUTO_TOKEN := 1;
END_IF
IF MQTT_INFO.MQTT_CONNECTED THEN
	SendFree := COM.S_BUF.SIZE = 0;	
END_IF

MQTT_IN_OUT.FB_NO_AUTO := 0;//reset FB number
MQTT_IN_OUT.OUT.DataRecived := FALSE;
CycleTime := OSCAT_BASIC.T_PLC_MS() - LastCycleTime;
LastCycleTime := OSCAT_BASIC.T_PLC_MS();
//get system time and so one
DT_MQTT(
	TDI_Data:= MQTT_IN_OUT.TDI);
	
TimeoutConnection(IN:= step = 10, PT:= T#5S);
SplitPublishLock := FALSE;

IF DebugFile THEN
		//open log file
		open(
	xExecute:= TRUE, 
	sFileName:= '/tmp/mqtt.log', 
	eFileMode:= 0, 
	xExclusive:= TRUE, 
	hFile=&gt; LogFile);
END_IF

//check if there is publish data in buffer and if so publish to application....
IF PublishReciveBufferCount &gt; 0 THEN
	PublishReciveTopicLengt := DWORD_TO_WORD(OSCAT_BASIC.DWORD_OF_BYTE(B3:= PublishReciveBuffer[0],
						 B2:= PublishReciveBuffer[1],
						 B1:= PublishReciveBuffer[2],
						 B0:= PublishReciveBuffer[3]));
	PublishRecivePayloadLengt := DWORD_TO_WORD(OSCAT_BASIC.DWORD_OF_BYTE(B3:= PublishReciveBuffer[PublishReciveTopicLengt + SIZE_PAKET_BUFFER_HEADER],
						 B2:= PublishReciveBuffer[PublishReciveTopicLengt + SIZE_PAKET_BUFFER_HEADER + 1],
						 B1:= PublishReciveBuffer[PublishReciveTopicLengt + SIZE_PAKET_BUFFER_HEADER + 2],
						 B0:= PublishReciveBuffer[PublishReciveTopicLengt + SIZE_PAKET_BUFFER_HEADER + 3]));
	//now move memmory down
	//get next pos --&gt; size of buffer reserved
	OutputPublish(
	PayloadSize:= PublishRecivePayloadLengt, 
	PayloadPos:= ADR(PublishReciveBuffer[PublishReciveTopicLengt + 2 * SIZE_PAKET_BUFFER_HEADER]), 
	TopicSize:= PublishReciveTopicLengt, 
	TopicPos:= ADR(PublishReciveBuffer[SIZE_PAKET_BUFFER_HEADER]), 
	MQTT_IN_OUT:= ADR(MQTT_IN_OUT), 
	NeedMove:= TRUE);
	MQTT_IN_OUT.OUT.MqttPayloadSize := PublishRecivePayloadLengt;
	//calculate new assingment size
	PublishReciveBufferAssignment := PublishReciveBufferAssignment - (PublishReciveTopicLengt + PublishRecivePayloadLengt + 2 * SIZE_PAKET_BUFFER_HEADER);
	MEM.MemMove(pSource:= ADR(PublishReciveBuffer[PublishReciveTopicLengt + PublishRecivePayloadLengt + 2 * SIZE_PAKET_BUFFER_HEADER]),
		pDestination:= ADR(PublishReciveBuffer[0]),
		uiNumberOfBytes:= UDINT_TO_UINT(PublishReciveBufferAssignment));
	PublishReciveBufferCount := PublishReciveBufferCount - 1;
END_IF

CASE step OF

	00:	IF ENABLE THEN
			MQTT_IN_OUT.handleFB := THIS;
	
			PUBREC_ERROR_INDEX := 0;
			CountRepeatedPingDisconnect := 0;
			SendetBytes := 0;
			RecivedBytes := 0;		
			PublishSplited := FALSE;
			DoDisconnect := FALSE;
			SendInfos.PingNeeded := FALSE;
			//SendInfos.PublishNeeded := FALSE;
			//SendInfos.PubrelNeeded := FALSE;
			SendInfos.SubscribeNeeded := FALSE;
			SendInfos.UnsubscribeNeeded := FALSE;
			StepBuildPublish := 0;
			StepBuildSubscribe := 0;
			StepBuildUnsubscribe := 0;
			InsertSplitTopic.reset();
			InsertSplitPayload.reset();
			CountConnectAttempt := CountConnectAttempt + 1;
			DynMemUsagePointer := ADR(MQTT_IN_OUT.dynMemUsage);
			COM.MQTT_URL := URL;
			COM.TIMEOUT := TIMEOUT;
			COM.CLIENT_ID := MQTT_IN_OUT.ClientID;
			COM.TLS := TLS;
			COM.TLS_CONFIG := MQTT_IN_OUT.TLS_CONFIG;
			ResetPingTime();
			//build will topic
			{info 'check build will topic'}
			TmpString := MQTT_IN_OUT.WillTopicBase;
			TmpString := Standard.CONCAT(STR1:= TmpString, '/');
			TmpString := Standard.CONCAT(STR1:= TmpString, STR2:= COM.CLIENT_ID);
			TmpString := Standard.CONCAT(STR1:= TmpString, '/');
			TmpString := Standard.CONCAT(STR1:= TmpString, MQTT_IN_OUT.ClientWillTopic);
			COM.CLIENT_WILL_TOPIC := TmpString;
			COM.CLIENT_WILL_MESSAGE_DEAD := MQTT_IN_OUT.ClientWillMessage;
			COM_CONFIG := MQTT_IN_OUT.COM_CONFIG;
			FOR i1 := 0 TO QoS_BUFFER_SIZE - 1 DO
				//reset in slots
				InData[i1].step := STEPS_IN.WAIT_DATA;
				OutData[i1].step := STEPS_OUT.WAIT_DATA;
			END_FOR
			
			SplitTopic.FullInit(TopicsLevelInit:= COM_CONFIG.MaxTopicLevels, SplitElementSizeInit:= COM_CONFIG.MaxTopicElementSize, dynMemUsageInit:= ADR(MQTT_IN_OUT.dynMemUsage));
			MQTT_IN_OUT.OUT.Topics := SplitTopic.GetSplitTopic(); 
			PayloadMemorySize := COM_CONFIG.MaxPayloadSize;
			{warning disable C0033}
			TopicMemorySize := COM_CONFIG.MaxTopicElementSize * COM_CONFIG.MaxTopicLevels;
			MaxPublishPacketSize := (COM_CONFIG.MaxTopicElementSize * COM_CONFIG.MaxTopicLevels) + PayloadMemorySize;
			SplitPublishBuffer  := SysMem23.SysMemAlloc(dwSize:= MaxPublishPacketSize + SPLIT_PUBLISH_BUFFER_ADDITIONAL_RAM);//some additional bytes for paket overhead
			MQTT_IN_OUT.dynMemUsage := MQTT_IN_OUT.dynMemUsage + MaxPublishPacketSize + SPLIT_PUBLISH_BUFFER_ADDITIONAL_RAM;
			{warning restore C0033}

			step := 10;
			COM.MQTT_CON := TRUE;
				
					
		
		END_IF;
	10:	IF MQTT_INFO.MQTT_CONNECTED THEN
			step := 40;
		END_IF;
		IF TimeoutConnection.Q THEN
			step := 0;//reset steps
			destroy();
		END_IF
	40:	
		IF PublishSplited THEN
			MergeSplitedPublish(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
		END_IF	
		ParseIncoming(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
		PublishSendListCount := 0;
		PubrelSendListCount := 0;
		PubackSendListCount := 0;
		PubrecSendListCount := 0;
		PubcompSendListCount := 0;
		StateMashineIn(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
		StateMashineOut( MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
		
		SendOutData(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
		SendInData(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
	
		IF MQTT_IN_OUT.TDI.IMP THEN
			PublishsSendPerSeconde := CounterPublishSendForMonitor;
			CounterPublishSendForMonitor := 0;
			PublishsRecivedPerSeconde := CounterPublishRecivedForMonitor;
			CounterPublishRecivedForMonitor := 0;
		END_IF
		IF COM.S_BUF.SIZE = 0 THEN
			CountNothingSend := CountNothingSend + 1;
		END_IF
		IF NOT ENABLE THEN 	(* beenden? *)
			step := 50;
			
		END_IF;
		IF DoDisconnect THEN
			DoDisconnect := FALSE;
			//here hard disconnect
			COM.MQTT_CON := FALSE; (* MQTT Verbindung beenden *)
			COM.MQTT_ABORT := TRUE;
			
			step := 60;
		END_IF

(* ~~~~~~~~~~~~~~~~~~~~~~ *)

50: 
	COM.MQTT_CON := FALSE; (* MQTT Verbindung beenden *)
	
	step := 60;//wait for disconnect
60:
	IF MQTT_INFO.MQTT_CONNECTED = FALSE THEN
		destroy();
		step := 0;
		
	END_IF
END_CASE;



(* ########################## *)

IF CountRepeatedPingDisconnect &gt; MAX_PING_REPEATS THEN
	DoDisconnect := TRUE;
END_IF


SendetBytes := SendetBytes + COM.S_BUF.SIZE;
MQTT_CONTROL(COM:= COM, INFO:=MQTT_INFO);
RecivedBytes := RecivedBytes + COM.R_BUF.SIZE;
ERROR_C := COM.ERROR_C;
ERROR_T := COM.ERROR_T;
//handl ping telegram
IF NextPingTime &lt; TICKS.GetTick(xDummy:= TRUE) AND NOT PingRequestet AND ENABLE THEN
	
	MakePingPaket(MQTT_IN_OUT := MQTT_IN_OUT);
	
END_IF

IF COM.ERROR_T &gt; BYTE#0 THEN  (* FEHLER *)
	step := 0;
END_IF;
//put status to local clients
MQTT_IN_OUT.BROKER_CONNECTED := MQTT_INFO.MQTT_CONNECTED;
(* ########################## *)

(* revision history


*)</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="ResetPingTime" ObjectId="6b44b8d0-7adf-48d8-b75c-dd2acfbff3a1">
              <interface />
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">NextPingTime := PingTime + TICKS.GetTick(xDummy:= TRUE);
CountRepeatedPingDisconnect := 0;</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="MakePingPaket" ObjectId="f2386f31-8fa4-46c4-b65c-985254494317">
              <interface>
                <inOutVars>
                  <variable name="MQTT_IN_OUT">
                    <type>
                      <derived name="MQTT_IN_OUT" />
                    </type>
                  </variable>
                </inOutVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">IF MQTT_IN_OUT.InFree THEN 
	MQTT_IN_OUT.IN := ADR(PingData); //set request
	PingData.PaketData.MessageType := MESSAGETYPE.PINGREQ;
	PingData.PaketData.FbId := myFbNo;
	MQTT_IN_OUT.InFree := FALSE;
	PingRequestet := TRUE;
END_IF
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="StateMashineOut" ObjectId="76450c13-0057-4d67-9911-3a23329af831">
              <interface>
                <inputVars>
                  <variable name="MQTT_IN_OUT">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="MQTT_IN_OUT" />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">StepData:POINTER TO MQTT_OUT_DATA;</xhtml>
                    </documentation>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="i">
                    <type>
                      <INT />
                    </type>
                  </variable>
                  <variable name="j">
                    <type>
                      <INT />
                    </type>
                  </variable>
                  <variable name="tmpLowest">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                  <variable name="minIndex">
                    <type>
                      <INT />
                    </type>
                  </variable>
                  <variable name="UnsubscribeLastHighest">
                    <type>
                      <UINT />
                    </type>
                    <initialValue>
                      <simpleValue value="16#FFFF" />
                    </initialValue>
                  </variable>
                  <variable name="SubscribeLastHighest">
                    <type>
                      <UINT />
                    </type>
                    <initialValue>
                      <simpleValue value="16#FFFF" />
                    </initialValue>
                  </variable>
                  <variable name="RecivePaketID">
                    <type>
                      <WORD />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">	PublishLastHighest : UINT := 16#FFFF;
	PubrelLastHighest : UINT := 16#FFFF;</xhtml>
                    </documentation>
                  </variable>
                  <variable name="RecivePakteType">
                    <type>
                      <BYTE />
                    </type>
                  </variable>
                  <variable name="TempSlotsWorking">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">(*need a token for coordinate send of pakets....
prio for Awnser and repeat pakets bevor new publish
dont use token, just send paket with next publish index*)
//get paket id
RecivePaketID := DWORD_TO_WORD(OSCAT_BASIC.DWORD_OF_BYTE(B3:= 0, B2:= 0, B1:= COM.R_BUF.BUFFER[2], B0:= COM.R_BUF.BUFFER[3]));
RecivePakteType := COM.R_BUF.BUFFER[0] AND 16#F0; 

GVL_MQTT.ProgNum := PROG_NUM.STATE_MASHINE_OUT;
PublishSendListCount := 0;
PubrelSendListCount := 0;

TempSlotsWorking := 0;
FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
	//do Timers...
	OutData[i].TimeOut(IN:= OutData[i].TimeOutStarted, PT:= MyConstants.REPEAT_TIMEOUT);
	CASE OutData[i].step OF
		
		STEPS_OUT.WAIT_DATA:
			OutData[i].TimeOutStarted := FALSE;
		IF NOT MQTT_IN_OUT^.InFree THEN//new Data from FBs
			MQTT_IN_OUT^.InFree := TRUE;
			OutData[i].InDataFromFb := MQTT_IN_OUT^.In;//set Data
			//Pakte id = slot + 1....
			OutData[i].InDataFromFb^.PaketId := INT_TO_UINT(i + 1);
			CASE OutData[i].InDataFromFb^.MessageType OF
				MESSAGETYPE.PUBLISH:
					OutgoingPublishOrderIndexCounter := OutgoingPublishOrderIndexCounter + 1;
					OutData[i].PUBLISHOrder :=  OutgoingPublishOrderIndexCounter;
					OutData[i].step := STEPS_OUT.SEND_PUBLSIH;
					CountSendedPublishs := CountSendedPublishs + 1;
					CounterPublishSendForMonitor := CounterPublishSendForMonitor + 1;
					OutData[i].PUBRELRepeatCounter := 0;
				MESSAGETYPE.PINGREQ:
					OutData[i].step := STEPS_OUT.WAIT_PINGRESP;
					SendInfos.PingNeeded := TRUE;
					SendInfos.PingIndex := i;
					PingSlot := i;
				//we only sending one subscription per subscribe paket....
				MESSAGETYPE.SUBSCRIBE:
					OutData[i].step := STEPS_OUT.SEND_SUBSCRIBE;
				MESSAGETYPE.UNSUBSCRIBE:
					OutData[i].step := STEPS_OUT.SEND_UNSUBSCRIBE;
			END_CASE
			
		END_IF
		
		STEPS_OUT.WAIT_PINGRESP:
			IF OutData[i].TimeOutStarted AND OutData[i].TimeOut.Q AND NOT SendInfos.PingNeeded THEN
				//timeout, need repead
				SendInfos.PingNeeded := TRUE;
				SendInfos.PingIndex := i;
				CountRepeatedPing := CountRepeatedPing + 1; 
				CountRepeatedPingDisconnect := CountRepeatedPingDisconnect + 1;
				OutData[i].TimeOutStarted := FALSE;
			END_IF
		STEPS_OUT.SEND_UNSUBSCRIBE:
			//check if my paket ID is the lowest to send it
			IF OutData[i].InDataFromFb^.PaketId &lt; UnsubscribeLastHighest AND NOT SendInfos.UnsubscribeNeeded THEN
				SendInfos.UnsubscribeIndex := i;
				SendInfos.UnsubscribeNeeded := TRUE;
				UnsubscribeLastHighest := OutData[i].InDataFromFb^.PaketId;
			END_IF	
		STEPS_OUT.WAIT_UNSUBACK:
			IF OutData[i].TimeOutStarted AND OutData[i].TimeOut.Q THEN
				//timeout, need repead
				OutData[i].step := STEPS_OUT.SEND_UNSUBSCRIBE;//repeat subscribe
				CountRepeatUnsubscribe := CountRepeatUnsubscribe + 1;
				OutData[i].TimeOutStarted := FALSE;
			END_IF
		STEPS_OUT.SEND_SUBSCRIBE:
			//check if my paket ID is the lowest to send it
			IF OutData[i].InDataFromFb^.PaketId &lt; SubscribeLastHighest AND NOT SendInfos.SubscribeNeeded THEN
				SendInfos.SubscribeIndex := i;
				SendInfos.SubscribeNeeded := TRUE;
				SubscribeLastHighest := OutData[i].InDataFromFb^.PaketId;
			END_IF	
		STEPS_OUT.WAIT_SUBACK:
			IF OutData[i].TimeOutStarted AND OutData[i].TimeOut.Q THEN
				//timeout, need repead
				OutData[i].step := STEPS_OUT.SEND_SUBSCRIBE;//repeat subscribe
				CountRepeatSubscribe := CountRepeatSubscribe + 1;
				OutData[i].TimeOutStarted := FALSE;
			END_IF
			
		STEPS_OUT.SEND_PUBLSIH:
			PublishSendList[PublishSendListCount] := i;
			PublishSendListCount := PublishSendListCount + 1;
			//check if my paket ID is the lowest to send it
			(*IF OutData[i].PUBLISHOrder &lt; PublishLastHighest THEN
				SendInfos.PublishIndex := i;
				SendInfos.PublishNeeded := TRUE;
				PublishLastHighest := OutData[i].PUBLISHOrder;
				OutData[i].WaitsForBuffFree := OutData[i].WaitsForBuffFree + 1;
			END_IF*)
			
		STEPS_OUT.WAIT_PUBACK:
			IF OutData[i].TimeOutStarted AND OutData[i].TimeOut.Q THEN
				//timeout, need repead
				OutData[i].InDataFromFb^.DUP := TRUE;
				OutData[i].step := STEPS_OUT.SEND_PUBLSIH;//repeat publish
				RepeatedPublish := RepeatedPublish + 1;
				OutData[i].TimeOutStarted := FALSE;
			END_IF
			
		STEPS_OUT.WAIT_PUBREC:
			IF OutData[i].TimeOutStarted AND OutData[i].TimeOut.Q THEN
				//timeout, need repead
				OutData[i].InDataFromFb^.DUP := TRUE;
				OutData[i].step := STEPS_OUT.SEND_PUBLSIH;//repeat publish
				RepeatedPublish := RepeatedPublish + 1;
				OutData[i].TimeOutStarted := FALSE;
			END_IF
			
		STEPS_OUT.SEND_PUBREL:
			PubrelSendList[PubrelSendListCount] := i;
			PubrelSendListCount := PubrelSendListCount + 1;
			
			//check if my Pubrec num is the lowest to send it
			(*IF OutData[i].PUBRECOrder &lt; PubrelLastHighest AND NOT SendInfos.PubrelNeeded THEN
				SendInfos.PubrelIndex := i;
				SendInfos.PubrelNeeded := TRUE;
				PubrelLastHighest := OutData[i].PUBRECOrder;
			END_IF*)
			
		STEPS_OUT.WAIT_PUBCOMP:
			IF OutData[i].TimeOutStarted AND OutData[i].TimeOut.Q THEN
				//timeout, need repead
				OutData[i].step := STEPS_OUT.SEND_PUBREL;//repeat pubrel
				RepeatedPubrel := RepeatedPubrel + 1;
				OutData[i].TimeOutStarted := FALSE;
				OutData[i].PUBRELRepeatCounter := OutData[i].PUBRELRepeatCounter + 1;
				IF OutData[i].PUBRELRepeatCounter &gt;= MyConstants.MAX_PUBREL_REPEATS THEN
					OutData[i].PUBRELRepeatCounter := 0;
					//resend publish
					OutData[i].step := STEPS_OUT.SEND_PUBLSIH;
					OutData[i].InDataFromFb^.DUP := TRUE;
					RepeatedPublishsAfterPubrel := RepeatedPublishsAfterPubrel + 1;
				END_IF
			END_IF
		IF NOT (OutData[i].step = STEPS_OUT.WAIT_DATA) THEN
			TempSlotsWorking := TempSlotsWorking + 1;
		END_IF
	END_CASE
	//make sure timer is set to 0 if timeout resetet
	OutData[i].TimeOut(IN:= OutData[i].TimeOutStarted, PT:= MyConstants.REPEAT_TIMEOUT);
END_FOR

//now sort the arrays...
IF PublishSendListCount &gt; 1 THEN
	FOR i := 0 TO PublishSendListCount - 1 DO
		tmpLowest := 16#FFFF;
		minIndex := i;
		FOR j := i TO PublishSendListCount - 1 DO
			IF OutData[PublishSendList[j]].PUBLISHOrder &lt; tmpLowest THEN
				minIndex := j;
				tmpLowest := OutData[PublishSendList[j]].PUBLISHOrder;
			END_IF
		END_FOR
		IF minIndex &lt;&gt; i THEN
			//hier tauschen
			j := PublishSendList[minIndex];
			PublishSendList[minIndex] := PublishSendList[i];
			PublishSendList[i] := j;
		END_IF
	END_FOR
END_IF

IF PubrelSendListCount &gt; 1 THEN
	FOR i := 0 TO PubrelSendListCount - 1 DO
		tmpLowest := 16#FFFF;
		minIndex := i;
		FOR j := i TO PubrelSendListCount - 1 DO
			IF OutData[PubrelSendList[j]].PUBRECOrder &lt; tmpLowest THEN
				minIndex := j;
				tmpLowest := OutData[PubrelSendList[j]].PUBRECOrder;
			END_IF
		END_FOR
		IF minIndex &lt;&gt; i THEN
			//hier tauschen
			j := PubrelSendList[minIndex];
			PubrelSendList[minIndex] := PubrelSendList[i];
			PubrelSendList[i] := j;
		END_IF
	END_FOR
END_IF

//Hamdel PubrelOrderIndexCounter
IF PubrelOrderIndexCounter &gt; MyConstants.REORDER_VALUE THEN 
	//do it brute force, just sub 20000 to every value...
	FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
		OutData[i].PUBRECOrder := OutData[i].PUBRECOrder - MyConstants.SUBSTRACTION_VALUE;
	END_FOR
	PubrelOrderIndexCounter := MyConstants.REORDER_VALUE - MyConstants.SUBSTRACTION_VALUE + 1;
END_IF
//Hamdel PublishOrderIndexCounter
IF OutgoingPublishOrderIndexCounter &gt; MyConstants.REORDER_VALUE THEN 
	//do it brute force, just sub 20000 to every value...
	FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
		OutData[i].PUBLISHOrder := OutData[i].PUBLISHOrder - MyConstants.SUBSTRACTION_VALUE;
	END_FOR
	OutgoingPublishOrderIndexCounter := MyConstants.REORDER_VALUE - MyConstants.SUBSTRACTION_VALUE + 1;
END_IF

OutSlotsWorking := TempSlotsWorking;</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="StateMashineIn" ObjectId="d87fe352-763e-4ff2-8fe2-b22ed364192e">
              <interface>
                <inputVars>
                  <variable name="MQTT_IN_OUT">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="MQTT_IN_OUT" />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="i">
                    <type>
                      <INT />
                    </type>
                  </variable>
                  <variable name="j">
                    <type>
                      <INT />
                    </type>
                  </variable>
                  <variable name="TempSlotsWorking">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                  <variable name="tmpLowest">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                  <variable name="minIndex">
                    <type>
                      <INT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">//RecivePakteType := COM.R_BUF.BUFFER[0] AND 16#F0;
GVL_MQTT.ProgNum := PROG_NUM.STATE_MASHINE_IN;
//Handle State Mashines
PubackSendListCount := 0;
PubrecSendListCount := 0;
PubcompSendListCount := 0;
TempSlotsWorking := 0;
FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
	//do Timers...
	InData[i].TimeOut(IN:= InData[i].TimeOutStarted, PT:= MyConstants.REPEAT_TIMEOUT);
	IF NOT (InData[i].step = STEPS_IN.WAIT_DATA) THEN
		TempSlotsWorking := TempSlotsWorking + 1;
	END_IF  
	CASE InData[i].step OF
		STEPS_IN.WAIT_DATA:;
		STEPS_IN.WAIT_PUBREL:
		IF InData[i].TimeOut.Q THEN
			InData[i].step := STEPS_IN.SEND_PUBREC;
			InData[i].TimeOutStarted := FALSE;
			CountRepeatetPubrec := CountRepeatetPubrec + 1;
			PUBREC_ERROR_ID_BUFFER[PUBREC_ERROR_INDEX] := InData[i].PaketID; 
			PUBREC_ERROR_INDEX := PUBREC_ERROR_INDEX + 1;
			InData[i].CountPubrecRepeat := InData[i].CountPubrecRepeat + 1;
			IF InData[i].CountPubrecRepeat &gt; COUNT_MAX_PUBREC_REPEAT_TO_DISCHARGE THEN
				InData[i].CountPubrecRepeat := 0;
				InData[i].step := STEPS_IN.WAIT_DATA;
			END_IF
			IF PUBREC_ERROR_INDEX &gt;= PUBREC_ERROR_ID_BUFFER_SIZE THEN
				PUBREC_ERROR_INDEX := 0;
			END_IF
		END_IF
		STEPS_IN.SEND_PUBACK:
			PubackSendList[PubackSendListCount] := i;
			PubackSendListCount := PubackSendListCount + 1;
			(*IF InData[i].PUBLISHOrder &lt; PublishLastHighest AND NOT SendInfos.PubackNeeded THEN
				SendInfos.PubackIndex := i;
				SendInfos.PubackNeeded := TRUE;
				PublishLastHighest := InData[i].PUBLISHOrder;
			END_IF*)
		STEPS_IN.SEND_PUBREC:
			PubrecSendList[PubrecSendListCount] := i;
			PubrecSendListCount := PubrecSendListCount + 1;
		(*IF InData[i].PUBLISHOrder &lt; PublishLastHighest AND NOT SendInfos.PubrecNeeded THEN
				SendInfos.PubrecIndex := i;
				SendInfos.PubrecNeeded := TRUE;
				PublishLastHighest := InData[i].PUBLISHOrder;
		END_IF*)
		STEPS_IN.SEND_PUBCOMP:
			PubcompSendList[PubcompSendListCount] := i;
			PubcompSendListCount := PubcompSendListCount + 1;
		(*IF InData[i].PUBCOMPOrder &lt; PubcompLastHighest AND NOT SendInfos.PubcompNeeded THEN
				SendInfos.PubcompIndex := i;
				SendInfos.PubcompNeeded := TRUE;
				PubcompLastHighest := InData[i].PUBCOMPOrder;
		END_IF*)
	END_CASE
	//make sure timer is set to 0 if timeout resetet
	InData[i].TimeOut(IN:= InData[i].TimeOutStarted, PT:= MyConstants.REPEAT_TIMEOUT);
END_FOR


//now sort the arrays...
IF PubackSendListCount &gt; 1 THEN
	FOR i := 0 TO PubackSendListCount - 1 DO
		tmpLowest := 16#FFFF;
		minIndex := i;
		FOR j := i TO PubackSendListCount - 1 DO
			IF InData[PubackSendList[j]].PUBLISHOrder &lt; tmpLowest THEN
				minIndex := j;
				tmpLowest := InData[PubackSendList[j]].PUBLISHOrder;
			END_IF
		END_FOR
		IF minIndex &lt;&gt; i THEN
			//hier tauschen
			j := PubackSendList[minIndex];
			PubackSendList[minIndex] := PubackSendList[i];
			PubackSendList[i] := j;
		END_IF
	END_FOR
END_IF

IF PubrecSendListCount &gt; 1 THEN
	FOR i := 0 TO PubrecSendListCount - 1 DO
		tmpLowest := 16#FFFF;
		minIndex := i;
		FOR j := i TO PubrecSendListCount - 1 DO
			IF InData[PubrecSendList[j]].PUBLISHOrder &lt; tmpLowest THEN
				minIndex := j;
				tmpLowest := InData[PubrecSendList[j]].PUBLISHOrder;
			END_IF
		END_FOR
		IF minIndex &lt;&gt; i THEN
			//hier tauschen
			j := PubrecSendList[minIndex];
			PubrecSendList[minIndex] := PubrecSendList[i];
			PubrecSendList[i] := j;
		END_IF
	END_FOR
END_IF


IF PubcompSendListCount &gt; 1 THEN
	FOR i := 0 TO PubcompSendListCount - 1 DO
		tmpLowest := 16#FFFF;
		minIndex := i;
		FOR j := i TO PubcompSendListCount - 1 DO
			IF InData[PubcompSendList[j]].PUBCOMPOrder &lt; tmpLowest THEN
				minIndex := j;
				tmpLowest := InData[PubcompSendList[j]].PUBCOMPOrder;
			END_IF
		END_FOR
		IF minIndex &lt;&gt; i THEN
			//hier tauschen
			j := PubcompSendList[minIndex];
			PubcompSendList[minIndex] := PubcompSendList[i];
			PubcompSendList[i] := j;
		END_IF
	END_FOR
END_IF
//Hamdel PublishOrderIndexCounter
IF IncomingPublishOrderIndexCounter &gt; MyConstants.REORDER_VALUE THEN 
	//do it brute force, just sub 20000 to every value...
	FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
		InData[i].PUBLISHOrder := InData[i].PUBLISHOrder - MyConstants.SUBSTRACTION_VALUE;
	END_FOR
	IncomingPublishOrderIndexCounter := MyConstants.REORDER_VALUE - MyConstants.SUBSTRACTION_VALUE + 1;
END_IF

//Hamdel PublishOrderIndexCounter
IF PubcompOrderIndexCounter &gt; MyConstants.REORDER_VALUE THEN 
	//do it brute force, just sub 20000 to every value...
	FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
		InData[i].PUBCOMPOrder := InData[i].PUBCOMPOrder - MyConstants.SUBSTRACTION_VALUE;
	END_FOR
	PubcompOrderIndexCounter := MyConstants.REORDER_VALUE - MyConstants.SUBSTRACTION_VALUE + 1;
END_IF

InSlotsWorking := TempSlotsWorking;</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="BuildPublishPaket" ObjectId="b579d915-d9ab-4cac-94a6-062255c7cdcc">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="PaketData">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="PAKET_DATA" />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="idx">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">(*now change to realy big topics and payloads, do that to big topics and payloads transmitted splitted*)

BuildPublishPaket := FALSE;
IF StepBuildPublish = 0 THEN
	StepBuildPublish := 10; 
END_IF

idx := COM.S_BUF.SIZE;
//check if buffer is big enought for control, remainig length, topic size....
IF StepBuildPublish = 10 THEN

	IF (6 + COM.S_BUF.SIZE)
		 &gt; TRANSMIT_BUFFER_SIZE THEN//only check if header fits into buffer...
		 CountCantSendPublishBufferToFull := CountCantSendPublishBufferToFull + 1;
		RETURN;	
	END_IF
	COM.S_BUF.BUFFER[idx] := MESSAGETYPE.PUBLISH;//set type
	IF PaketData^.DUP THEN//insert DUP bit
		COM.S_BUF.BUFFER[idx] := COM.S_BUF.BUFFER[idx] OR 2#1000;
	END_IF 
	COM.S_BUF.BUFFER[idx] := COM.S_BUF.BUFFER[idx] OR SHL(PaketData^.MessageQoS,1);
	IF PaketData^.MessageRetain THEN
		COM.S_BUF.BUFFER[idx] := COM.S_BUF.BUFFER[idx] OR 2#1;
	END_IF
	//do remainig lenght... 

	idx := idx + 2 + DoRemainingLengthBevor(buffer:= ADR(COM.S_BUF.BUFFER[idx]), SizeTopic:= PaketData^.MqttTopicLength, SizePayload:= PaketData^.MqttPayloadLength, InQoS:= PaketData^.MessageQoS);

	StepBuildPublish := 20;
END_IF

IF StepBuildPublish = 20 THEN
	GVL_MQTT.ProgNum := PROG_NUM.SendOutDataInsertTopic;
	//insert topic
	InsertSplitTopic(
		topic:= PaketData^.MqttTopic, 
		len:= PaketData^.MqttTopicLength, 
		buff:= ADR(COM.S_BUF.BUFFER), 
		pos:= idx, 
		size:= NETWORK_BUFFER_LONG_SIZE);
	CASE InsertSplitTopic.state OF
		INSERT_SPLIT_RETURN.INSERT_DONE:
			StepBuildPublish := 30;
		INSERT_SPLIT_RETURN.INSERT_ERROR:
			StepBuildPublish := 0;
			InsertSplitTopic.reset();
			RETURN;
		INSERT_SPLIT_RETURN.INSERT_PENDING:
			//here do nothing, just wait
		ELSE
			InsertSplitTopic.reset();
			StepBuildPublish := 0;
			RETURN;
	END_CASE
	idx := InsertSplitTopic.new_pos;
END_IF
IF StepBuildPublish = 30 THEN
	IF PaketData^.MessageQoS &gt; 0 THEN//QoS is more then 0
		IF (2 + idx)//insert paket identifier
		 &lt; TRANSMIT_BUFFER_SIZE THEN//enough space for identifier?
			COM.S_BUF.BUFFER[idx] := OSCAT_BASIC.BYTE_OF_DWORD(in:= PaketData^.PaketId, N:= 1);
			idx := idx + 1;
			COM.S_BUF.BUFFER[idx] := OSCAT_BASIC.BYTE_OF_DWORD(in:= PaketData^.PaketId, N:= 0);
			idx := idx + 1;
			StepBuildPublish := 40;
		END_IF
	ELSE
		StepBuildPublish := 40;
	END_IF
END_IF

IF StepBuildPublish = 40 THEN
	GVL_MQTT.ProgNum := PROG_NUM.SendOutDataInsertPayload;
	//now insert payload
	IF PaketData^.MqttPayloadLength &gt; 0 THEN
		//insert payload
		InsertSplitPayload(
			payload:= PaketData^.MqttPayload, 
			len:= PaketData^.MqttPayloadLength, 
			buff:= ADR(COM.S_BUF.BUFFER), 
			pos:= idx, 
			size:= NETWORK_BUFFER_LONG_SIZE);
		CASE InsertSplitPayload.state OF
			INSERT_SPLIT_RETURN.INSERT_DONE:
				StepBuildPublish := 0;
				BuildPublishPaket := TRUE;
			INSERT_SPLIT_RETURN.INSERT_ERROR:
				StepBuildPublish := 0;
				InsertSplitPayload.reset();
				RETURN;
			INSERT_SPLIT_RETURN.INSERT_PENDING:
				//here do nothing, just wait
				//or handle timeout....
			ELSE
				InsertSplitPayload.reset();
				StepBuildPublish := 0;
				RETURN;
		END_CASE
		idx := InsertSplitPayload.new_pos;
	ELSE
		StepBuildPublish := 0;
		BuildPublishPaket := TRUE;
	END_IF
END_IF
COM.S_BUF.SIZE := idx;
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="MoveBufferForSplitPaket" ObjectId="329db169-e7d1-4ba4-8fa9-f8151db084da">
              <interface>
                <inputVars>
                  <variable name="idx">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="BytesToMove">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">GVL_MQTT.ProgNum := PROG_NUM.MoveBuffer;
BytesToMove := COM.R_BUF.SIZE - idx;
CountBufferMoves := CountBufferMoves + 1;
MEM.MemMove(pSource:= ADR(com.R_BUF.BUFFER[idx]), pDestination:= ADR(com.R_BUF.BUFFER), uiNumberOfBytes:= BytesToMove);
COM.R_BUF.SIZE := BytesToMove;//manipulate size....
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="BuildSubscribePaket" ObjectId="cda195a3-d851-43ea-b874-50b26c5632c5">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="PaketData">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="PAKET_DATA" />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="idx">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">BuildSubscribePaket := FALSE;
IF  StepBuildSubscribe = 0 THEN
	StepBuildSubscribe := 10;
END_IF

idx := COM.S_BUF.SIZE;
IF StepBuildSubscribe = 10 THEN
	IF (6 + COM.S_BUF.SIZE)
	 &gt; TRANSMIT_BUFFER_SIZE THEN//only check if header fits into buffer...
		 RETURN;
	END_IF
	idx := COM.S_BUF.SIZE;
	COM.S_BUF.BUFFER[idx] := MESSAGETYPE.SUBSCRIBE OR 2#10;//set type, for 2#10 see subscribe doku
	idx := idx + 2 + DoRemainingLengthBevor(buffer:= ADR(COM.S_BUF.BUFFER[idx]), SizeTopic:= PaketData^.MqttTopicLength, SizePayload:= 1, InQoS:= QoS.AtLeastOnce);
	COM.S_BUF.BUFFER[idx] := OSCAT_BASIC.BYTE_OF_DWORD(in:= PaketData^.PaketId, N:= 1);
	idx := idx + 1;
	COM.S_BUF.BUFFER[idx] := OSCAT_BASIC.BYTE_OF_DWORD(in:= PaketData^.PaketId, N:= 0);
	idx := idx + 1;
	StepBuildSubscribe := 20;
END_IF


IF StepBuildSubscribe = 20 THEN
	//insert topic
	InsertSplitTopic(
		topic:= PaketData^.MqttTopic, 
		len:= PaketData^.MqttTopicLength, 
		buff:= ADR(COM.S_BUF.BUFFER), 
		pos:= idx, 
		size:= NETWORK_BUFFER_LONG_SIZE);
	CASE InsertSplitTopic.state OF
		INSERT_SPLIT_RETURN.INSERT_DONE:
			StepBuildSubscribe := 30;
		INSERT_SPLIT_RETURN.INSERT_ERROR:
			StepBuildSubscribe := 0;
			InsertSplitTopic.reset();
			RETURN;
		INSERT_SPLIT_RETURN.INSERT_PENDING:
			//here do nothing, just wait
		ELSE
			InsertSplitTopic.reset();
			StepBuildSubscribe := 0;
			RETURN;
	END_CASE
	idx := InsertSplitTopic.new_pos;
END_IF

IF StepBuildSubscribe = 30 THEN

	IF (1 + idx)
	 &gt; TRANSMIT_BUFFER_SIZE THEN//only check if qos fits into buffer...
		 RETURN;
	 END_IF
	//insert QoS
	COM.S_BUF.BUFFER[idx] := PaketData^.MessageQoS;
	idx := idx + 1;
	StepBuildSubscribe := 0;
	BuildSubscribePaket := TRUE;
END_IF

COM.S_BUF.SIZE := idx;</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="BuildUnsubscribePaket" ObjectId="688a96f0-99e0-4a03-95f7-16628eca43f4">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="PaketData">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="PAKET_DATA" />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="idx">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">BuildUnsubscribePaket := FALSE;

IF  StepBuildUnsubscribe = 0 THEN
	StepBuildUnsubscribe := 10;
END_IF

idx := COM.S_BUF.SIZE;
IF StepBuildUnsubscribe = 10 THEN
	IF (6 + COM.S_BUF.SIZE)
	 &gt; TRANSMIT_BUFFER_SIZE THEN//only check if header fits into buffer...
		 RETURN;
	END_IF
	idx := COM.S_BUF.SIZE;
	COM.S_BUF.BUFFER[idx] := MESSAGETYPE.UNSUBSCRIBE OR 2#10;//set type, for 2#10 see subscribe doku
	idx := idx + 2 + DoRemainingLengthBevor(buffer:= ADR(COM.S_BUF.BUFFER[idx]), SizeTopic:= PaketData^.MqttTopicLength, SizePayload:= 0, InQoS:= QoS.AtLeastOnce);
	COM.S_BUF.BUFFER[idx] := OSCAT_BASIC.BYTE_OF_DWORD(in:= PaketData^.PaketId, N:= 1);
	idx := idx + 1;
	COM.S_BUF.BUFFER[idx] := OSCAT_BASIC.BYTE_OF_DWORD(in:= PaketData^.PaketId, N:= 0);
	idx := idx + 1;
	StepBuildUnsubscribe := 20;
END_IF


IF StepBuildUnsubscribe = 20 THEN
	//insert topic
	InsertSplitTopic(
		topic:= PaketData^.MqttTopic, 
		len:= PaketData^.MqttTopicLength, 
		buff:= ADR(COM.S_BUF.BUFFER), 
		pos:= idx, 
		size:= NETWORK_BUFFER_LONG_SIZE);
	CASE InsertSplitTopic.state OF
		INSERT_SPLIT_RETURN.INSERT_DONE:
			StepBuildUnsubscribe := 0;
			BuildUnsubscribePaket := TRUE;
		INSERT_SPLIT_RETURN.INSERT_ERROR:
			StepBuildUnsubscribe := 0;
			InsertSplitTopic.reset();
			RETURN;
		INSERT_SPLIT_RETURN.INSERT_PENDING:
			//here do nothing, just wait
		ELSE
			InsertSplitTopic.reset();
			StepBuildUnsubscribe := 0;
			RETURN;
	END_CASE
	idx := InsertSplitTopic.new_pos;
END_IF

COM.S_BUF.SIZE := idx;
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="SendOutData" ObjectId="eaf44d39-53ab-4f9b-83b9-193ac4c883af">
              <interface>
                <inputVars>
                  <variable name="MQTT_IN_OUT">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="MQTT_IN_OUT" />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">StepData:POINTER TO MQTT_OUT_DATA;</xhtml>
                    </documentation>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="SomethingIsBlocking">
                    <type>
                      <BOOL />
                    </type>
                  </variable>
                  <variable name="i">
                    <type>
                      <INT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">IF NOT SendFree THEN RETURN; END_IF
GVL_MQTT.ProgNum := PROG_NUM.SendOutData;

SomethingIsBlocking := SendInfos.PublishBlocking OR SendInfos.SubscribeBlocking OR SendInfos.UnsubscribeBlocking;

//Prio for Timeout Paket
IF  NOT (COM.S_BUF.SIZE + SIZE_PINGREQ &gt; TRANSMIT_BUFFER_SIZE) AND SendInfos.PingNeeded AND NOT SomethingIsBlocking THEN
	SendInfos.PingNeeded := FALSE;
	COM.S_BUF.BUFFER[COM.S_BUF.SIZE] := MESSAGETYPE.PINGREQ;
	COM.S_BUF.BUFFER[COM.S_BUF.SIZE + 1] := 0;//no more length 	
	COM.S_BUF.SIZE := COM.S_BUF.SIZE + SIZE_PINGREQ;//small ping paket
	OutData[SendInfos.PingIndex].TimeOutStarted := TRUE;//start Timeout
END_IF
IF NOT COM.S_BUF.SIZE = 0 THEN 
	CountOutSendNotFree := CountOutSendNotFree + 1;
END_IF
//next Prio send Pubrel 
IF PubrelSendListCount &gt; 0 AND NOT SomethingIsBlocking THEN
	FOR i := 0 TO PubrelSendListCount - 1 DO
		IF NOT (COM.S_BUF.SIZE + SIZE_PUBREL &gt; TRANSMIT_BUFFER_SIZE) THEN
			//SendInfos.PubrelNeeded := FALSE;
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE] := MESSAGETYPE.PUBREL OR 2#10;//set type and Reserved bits
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE + 1] := 2;
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE + 2] := OSCAT_BASIC.BYTE_OF_DWORD(in:= OutData[PubrelSendList[i]].InDataFromFb^.PaketId, N:= 1);
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE + 3] := OSCAT_BASIC.BYTE_OF_DWORD(in:= OutData[PubrelSendList[i]].InDataFromFb^.PaketId, N:= 0);
			COM.S_BUF.SIZE := COM.S_BUF.SIZE + SIZE_PUBREL;
			OutData[PubrelSendList[i]].step := STEPS_OUT.WAIT_PUBCOMP;
			OutData[PubrelSendList[i]].TimeOutStarted := TRUE;//start Timeout			
		ELSE
			EXIT;
		END_IF 
	END_FOR
END_IF

//send Unsubscribe
IF SendInfos.UnsubscribeNeeded AND (NOT SomethingIsBlocking OR SendInfos.UnsubscribeBlocking) THEN
	IF NOT BuildUnsubscribePaket(PaketData:= OutData[SendInfos.UnsubscribeIndex].InDataFromFb) THEN
		SendInfos.UnsubscribeBlocking := TRUE;
	ELSE
		SendInfos.UnsubscribeBlocking := FALSE;
		SendInfos.UnsubscribeNeeded := FALSE;
		OutData[SendInfos.UnsubscribeIndex].TimeOutStarted := TRUE;
		OutData[SendInfos.UnsubscribeIndex].step := STEPS_OUT.WAIT_UNSUBACK;
	END_IF
END_IF

//send Subscribe
IF SendInfos.SubscribeNeeded AND (NOT SomethingIsBlocking OR SendInfos.SubscribeBlocking) THEN
	IF NOT BuildSubscribePaket(PaketData:= OutData[SendInfos.SubscribeIndex].InDataFromFb) THEN
		SendInfos.SubscribeBlocking := TRUE;
	ELSE
		SendInfos.SubscribeBlocking := FALSE;
		SendInfos.SubscribeNeeded := FALSE;
		OutData[SendInfos.SubscribeIndex].TimeOutStarted := TRUE;
		OutData[SendInfos.SubscribeIndex].step := STEPS_OUT.WAIT_SUBACK;
	END_IF
END_IF
//send Publish 
IF SendInfos.PublishBlocking THEN
	IF BuildPublishPaket(PaketData:= OutData[SendInfos.PublishBlockingIndex].InDataFromFb) THEN
		SendInfos.PublishBlocking := FALSE;
	END_IF
END_IF

IF (PublishSendListCount &gt; 0 AND NOT SomethingIsBlocking) THEN
	//handle pendig publisah packet
	//handle new publish packet
	FOR i := 0 TO PublishSendListCount - 1 DO
		IF NOT BuildPublishPaket(PaketData:= OutData[PublishSendList[i]].InDataFromFb) THEN
			SendInfos.PublishBlocking := TRUE;
			SendInfos.PublishBlockingIndex := PublishSendList[i];
			EXIT;
		ELSE 
			//SendInfos.PublishNeeded := FALSE;
			SendInfos.PublishBlocking := FALSE;
			//publish gone, increase token
		
			OutData[PublishSendList[i]].TimeOutStarted := TRUE;//start Timeout
			CASE OutData[PublishSendList[i]].InDataFromFb^.MessageQoS OF
				QoS.AtMostOnce:
				//paket gone and bye bye, on QoS 0 
				OutData[PublishSendList[i]].InDataFromFb^.SendSucsess := TRUE;
				OutData[PublishSendList[i]].step := STEPS_OUT.WAIT_DATA;//can get new data
				QoS.AtLeastOnce:
					OutData[PublishSendList[i]].step := STEPS_OUT.WAIT_PUBACK;//wait for ACK
					IF NOT OutData[PublishSendList[i]].InDataFromFb^.DUP THEN
						Publishsunacknowledged := Publishsunacknowledged + 1;
					END_IF
				QoS.ExactlyOnce:
					OutData[PublishSendList[i]].step := STEPS_OUT.WAIT_PUBREC;//wait for REC
					IF NOT OutData[PublishSendList[i]].InDataFromFb^.DUP THEN
						Publishsunacknowledged := Publishsunacknowledged + 1;
					END_IF
			END_CASE
		END_IF
	END_FOR
END_IF</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="SendInData" ObjectId="a7ea802c-6124-4ca3-9c46-9debb67a877b">
              <interface>
                <inputVars>
                  <variable name="MQTT_IN_OUT">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="MQTT_IN_OUT" />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="i">
                    <type>
                      <INT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">IF NOT SendFree THEN RETURN; END_IF

GVL_MQTT.ProgNum := PROG_NUM.SendInData;

IF NOT COM.S_BUF.SIZE = 0 THEN 
	CountInSendNotFree := CountInSendNotFree + 1;
END_IF

IF PubackSendListCount &gt; 0 THEN
	//SendInfos.PubackNeeded := FALSE;
	FOR i := 0 TO PubackSendListCount - 1 DO
		IF NOT (COM.S_BUF.SIZE + SIZE_PUBACK &gt; TRANSMIT_BUFFER_SIZE)  THEN
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE] := MESSAGETYPE.PUBACK;
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE + 1] := 2;//length of 2
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE + 2] := OSCAT_BASIC.BYTE_OF_DWORD(in:= InData[PubackSendList[i]].PaketID, N:= 1);
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE + 3] := OSCAT_BASIC.BYTE_OF_DWORD(in:= InData[PubackSendList[i]].PaketID, N:= 0);
			COM.S_BUF.SIZE := COM.S_BUF.SIZE + SIZE_PUBACK;//Paket size allways 4!
			InData[PubackSendList[i]].step := STEPS_IN.WAIT_DATA;
			MqttsDoneIo := MqttsDoneIo + 1;	
		ELSE
			EXIT;
		END_IF
	END_FOR
	
END_IF

IF PubcompSendListCount &gt; 0 THEN
	//SendInfos.PubcompNeeded := FALSE;
	FOR i := 0 TO PubcompSendListCount - 1 DO
		IF NOT (COM.S_BUF.SIZE + SIZE_PUBCOMP &gt; TRANSMIT_BUFFER_SIZE) THEN	
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE] := MESSAGETYPE.PUBCOMP;
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE + 1] := 2;//length of 2
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE + 2] := OSCAT_BASIC.BYTE_OF_DWORD(in:= InData[PubcompSendList[i]].PaketID, N:= 1);
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE + 3] := OSCAT_BASIC.BYTE_OF_DWORD(in:= InData[PubcompSendList[i]].PaketID, N:= 0);
			COM.S_BUF.SIZE := COM.S_BUF.SIZE + SIZE_PUBCOMP;//Paket size allways 4!
			InData[PubcompSendList[i]].step := STEPS_IN.WAIT_DATA;
			MqttsDoneIo := MqttsDoneIo + 1;
		ELSE
			EXIT;
		END_IF
	END_FOR
END_IF

IF PubrecSendListCount &gt; 0 THEN
	FOR i := 0 TO PubrecSendListCount - 1 DO
		IF NOT (COM.S_BUF.SIZE + SIZE_PUBREC &gt; TRANSMIT_BUFFER_SIZE) THEN
			//SendInfos.PubrecNeeded := FALSE;
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE] := MESSAGETYPE.PUBREC;
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE + 1] := 2;//length of 2
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE + 2] := OSCAT_BASIC.BYTE_OF_DWORD(in:= InData[PubrecSendList[i]].PaketID, N:= 1);
			COM.S_BUF.BUFFER[COM.S_BUF.SIZE + 3] := OSCAT_BASIC.BYTE_OF_DWORD(in:= InData[PubrecSendList[i]].PaketID, N:= 0);
			COM.S_BUF.SIZE := COM.S_BUF.SIZE + SIZE_PUBREC;//Paket size allways 4!
			InData[PubrecSendList[i]].step := STEPS_IN.WAIT_PUBREL;
			InData[PubrecSendList[i]].TimeOutStarted := TRUE;
		ELSE
			EXIT;
		END_IF
	END_FOR
END_IF
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="ParseIncoming" ObjectId="a0195934-de34-4282-bca7-4efe8c4c5b8c">
              <interface>
                <inputVars>
                  <variable name="MQTT_IN_OUT">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="MQTT_IN_OUT" />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="I">
                    <type>
                      <INT />
                    </type>
                  </variable>
                  <variable name="idx">
                    <type>
                      <UINT />
                    </type>
                    <initialValue>
                      <simpleValue value="0" />
                    </initialValue>
                  </variable>
                  <variable name="RecivePakteType">
                    <type>
                      <derived name="MESSAGETYPE" />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">idxFromParsePublish:UINT := 0;</xhtml>
                    </documentation>
                  </variable>
                  <variable name="RecivePaketID">
                    <type>
                      <WORD />
                    </type>
                  </variable>
                  <variable name="BufferMoveDone">
                    <type>
                      <BOOL />
                    </type>
                  </variable>
                  <variable name="PaketFound">
                    <type>
                      <BOOL />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">GVL_MQTT.ProgNum := PROG_NUM.ParseIncomming;
IF COM.R_BUF.SIZE &gt; 0 THEN
	REPEAT
		
		PaketFound := FALSE;
		HelperLastPaktetForUnkownPaket := RecivePakteType;
		RecivePakteType := COM.R_BUF.BUFFER[idx] AND 16#F0;
		 
		CASE RecivePakteType OF
			MESSAGETYPE.PUBLISH:
			//new way, move every publish to recive buffer, and then pars it.
			//outgoing payload pointer is then set to start of payload in the buffer....
				//don't use check buffer here, make all in Parse Publish....
				BufferMoveDone := CheckLenghtBuffer(IdxIn:= idx);
				IF NOT BufferMoveDone THEN
					
					idx := ParseIncomingPublish(MQTT_IN_OUT:= MQTT_IN_OUT, idx:= idx,
											BufferIn:= ADR(COM.R_BUF.BUFFER), NetworkBuffer:= TRUE, BufferSize:= COM.R_BUF.SIZE);

				END_IF
			MESSAGETYPE.PUBREL:
				BufferMoveDone := CheckLenghtBuffer(IdxIn:= idx);
				IF NOT BufferMoveDone THEN
					//get Paket ID
					RecivePaketID := DWORD_TO_WORD(OSCAT_BASIC.DWORD_OF_BYTE(B3:= 0, B2:= 0, 
						B1:= COM.R_BUF.BUFFER[idx + 2],
						B0:= COM.R_BUF.BUFFER[idx + 3]));
					//find Paket
					FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
						IF InData[i].PaketID = RecivePaketID THEN
							InData[i].step := STEPS_IN.SEND_PUBCOMP;
							InData[i].TimeOutStarted := FALSE;
							PubcompOrderIndexCounter := PubcompOrderIndexCounter;
							InData[i].PUBCOMPOrder := PubcompOrderIndexCounter;
							PaketFound := TRUE;
							EXIT;
						END_IF
						//
					END_FOR
					IF NOT PaketFound THEN
						CountRecivePubrelUnknown := CountRecivePubrelUnknown + 1;
					END_IF
					idx := idx + SIZE_PUBREL;
				END_IF
			MESSAGETYPE.PINGRESP:
				ResetPingTime();
				PingRequestet := FALSE;
				OutData[PingSlot].step := STEPS_OUT.WAIT_DATA;//can get new data
				OutData[PingSlot].TimeOutStarted := FALSE;
				idx := idx + SIZE_PINGRESP;
			MESSAGETYPE.UNSUBACK:
				BufferMoveDone := CheckLenghtBuffer(IdxIn:= idx);
				IF NOT BufferMoveDone THEN
					//get Paket ID
					RecivePaketID := DWORD_TO_WORD(OSCAT_BASIC.DWORD_OF_BYTE(B3:= 0, B2:= 0, 
						B1:= COM.R_BUF.BUFFER[idx + 2],
						B0:= COM.R_BUF.BUFFER[idx + 3]));
					//find Paket
					FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
						IF OutData[i].step = STEPS_OUT.WAIT_UNSUBACK THEN //make sure pointer is vailid
							IF OutData[i].InDataFromFb^.PaketId = RecivePaketID THEN
								OutData[i].InDataFromFb^.SendSucsess := TRUE;
								OutData[i].step := STEPS_OUT.WAIT_DATA;//can get new data
								OutData[i].TimeOutStarted := FALSE;
								MqttsDoneIo := MqttsDoneIo + 1;
								PaketFound := TRUE;
								EXIT;
							END_IF
						END_IF
						//
					END_FOR
					IF NOT PaketFound THEN
						CountReciveUnsubackUnknown := CountReciveUnsubackUnknown + 1;
					END_IF
					idx := idx + SIZE_UNSUBACK;	
				END_IF
				
			MESSAGETYPE.SUBACK:
				BufferMoveDone := CheckLenghtBuffer(IdxIn:= idx);
				IF NOT BufferMoveDone THEN
					//get Paket ID
					RecivePaketID := DWORD_TO_WORD(OSCAT_BASIC.DWORD_OF_BYTE(B3:= 0, B2:= 0, 
						B1:= COM.R_BUF.BUFFER[idx + 2],
						B0:= COM.R_BUF.BUFFER[idx + 3]));
					//find Paket
					FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
						IF OutData[i].step = STEPS_OUT.WAIT_SUBACK THEN //make sure pointer is vailid
							IF OutData[i].InDataFromFb^.PaketId = RecivePaketID THEN
								OutData[i].InDataFromFb^.SendSucsess := TRUE;
								OutData[i].InDataFromFb^.SubackQoS := COM.R_BUF.BUFFER[idx + 4];
								OutData[i].step := STEPS_OUT.WAIT_DATA;//can get new data
								OutData[i].TimeOutStarted := FALSE;
								MqttsDoneIo := MqttsDoneIo + 1;
								PaketFound := TRUE;
								EXIT;
							END_IF
						END_IF
						//
					END_FOR
					IF NOT PaketFound THEN
						CountReciveSubackUnknown := CountReciveSubackUnknown + 1;
					END_IF
					idx := idx + SIZE_SUBACK;//only one QoS response expected
				END_IF
			MESSAGETYPE.PUBACK:
				BufferMoveDone := CheckLenghtBuffer(IdxIn:= idx);
				IF NOT BufferMoveDone THEN
					//get Paket ID
					RecivePaketID := DWORD_TO_WORD(OSCAT_BASIC.DWORD_OF_BYTE(B3:= 0, B2:= 0, 
						B1:= COM.R_BUF.BUFFER[idx + 2],
						B0:= COM.R_BUF.BUFFER[idx + 3]));
					//find Paket
					FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
						IF OutData[i].step = STEPS_OUT.WAIT_PUBACK THEN //make sure pointer is vailid
							IF OutData[i].InDataFromFb^.PaketId = RecivePaketID THEN
								OutData[i].InDataFromFb^.SendSucsess := TRUE;
								OutData[i].step := STEPS_OUT.WAIT_DATA;//can get new data
								OutData[i].TimeOutStarted := FALSE;
								MqttsDoneIo := MqttsDoneIo + 1;
								Publishsunacknowledged := Publishsunacknowledged - 1;
								PaketFound := TRUE; 
								EXIT;
							END_IF
						END_IF
						//
					END_FOR
					IF NOT PaketFound THEN
						CountRecivePubackUnknown := CountRecivePubackUnknown + 1;
					END_IF
					idx := idx + SIZE_PUBACK;
				END_IF
			MESSAGETYPE.PUBREC:
				BufferMoveDone := CheckLenghtBuffer(IdxIn:= idx);
				IF NOT BufferMoveDone THEN
					//get Paket ID
					RecivePaketID := DWORD_TO_WORD(OSCAT_BASIC.DWORD_OF_BYTE(B3:= 0, B2:= 0, 
						B1:= COM.R_BUF.BUFFER[idx + 2],
						B0:= COM.R_BUF.BUFFER[idx + 3]));
					//find Paket
					FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
						IF OutData[i].step = STEPS_OUT.WAIT_PUBREC THEN //make sure pointer is vailid
							IF OutData[i].InDataFromFb^.PaketId = RecivePaketID THEN
								IF NOT OutData[i].InDataFromFb^.DUP THEN
									//increase only at first handle 
									PubrelOrderIndexCounter := PubrelOrderIndexCounter + 1;
									OutData[i].PUBRECOrder := PubrelOrderIndexCounter;
								END_IF
								OutData[i].step := STEPS_OUT.SEND_PUBREL;
								OutData[i].TimeOutStarted := FALSE;
								PaketFound := TRUE; 
								EXIT;
							END_IF
						END_IF
						//
					END_FOR
					IF NOT PaketFound THEN
						CountRecivePubrecUnknown := CountRecivePubrecUnknown + 1;
					END_IF
					idx := idx + SIZE_PUBREC;
				END_IF
			MESSAGETYPE.PUBCOMP:
				BufferMoveDone := CheckLenghtBuffer(IdxIn:= idx);
				IF NOT BufferMoveDone THEN
					//get Paket ID
					RecivePaketID := DWORD_TO_WORD(OSCAT_BASIC.DWORD_OF_BYTE(B3:= 0, B2:= 0, 
						B1:= COM.R_BUF.BUFFER[idx + 2],
						B0:= COM.R_BUF.BUFFER[idx + 3]));
					//find Paket
					FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
						IF OutData[i].step = STEPS_OUT.WAIT_PUBCOMP THEN //make sure pointer is vailid
							IF OutData[i].InDataFromFb^.PaketId = RecivePaketID THEN
								OutData[i].InDataFromFb^.SendSucsess := TRUE;
								OutData[i].step := STEPS_OUT.WAIT_DATA;//can get new data
								OutData[i].TimeOutStarted := FALSE;
								MqttsDoneIo := MqttsDoneIo + 1;
								Publishsunacknowledged := Publishsunacknowledged - 1;
								PaketFound := TRUE;
								EXIT;
							END_IF
						END_IF
						//
					END_FOR
					IF NOT PaketFound THEN
						CountRecivePubcompUnknown := CountRecivePubcompUnknown + 1;
					END_IF
					idx := idx + SIZE_PUBCOMP;			
				END_IF
			ELSE
				//unknown paket, reset buffer....
				//standard wants to disconnect....
				{info 'unkown packet, disconnect'}
				LastPaktetForUnkownPaket := HelperLastPaktetForUnkownPaket;
				COM.R_BUF.SIZE := 0;	
				//unknown paket recived
				NotKnownPaket := COM.R_BUF.BUFFER[0] AND 16#F0;
				//alway reset recive!
				COM.MQTT_RCV_STATE := BYTE#0;//recive zurücksetzten
				COM.R_BUF.SIZE := 0;
				CountUnkownPaket := CountUnkownPaket + 1;	
		END_CASE
	UNTIL
		idx &gt;= COM.R_BUF.SIZE
	END_REPEAT
	IF NOT BufferMoveDone THEN
		COM.R_BUF.SIZE := 0;
		COM.MQTT_RCV_STATE := BYTE#0;//recive zurücksetzten	
	END_IF
	
END_IF</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="ParseIncomingPublish" ObjectId="e0043f8f-3a31-4d50-8659-2ad99197624b">
              <interface>
                <returnType>
                  <UINT />
                </returnType>
                <inputVars>
                  <variable name="MQTT_IN_OUT">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="MQTT_IN_OUT" />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                  <variable name="idx">
                    <type>
                      <UINT />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">pos of paket in buffer</xhtml>
                    </documentation>
                  </variable>
                  <variable name="BufferIn">
                    <type>
                      <pointer>
                        <baseType>
                          <BYTE />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">give here the buffer were the full pacet is...</xhtml>
                    </documentation>
                  </variable>
                  <variable name="NetworkBuffer">
                    <type>
                      <BOOL />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">works on network buffer --&gt; need memmove in Output</xhtml>
                    </documentation>
                  </variable>
                  <variable name="BufferSize">
                    <type>
                      <UDINT />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">size of buffer</xhtml>
                    </documentation>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="i">
                    <type>
                      <INT />
                    </type>
                  </variable>
                  <variable name="PaketFound">
                    <type>
                      <BOOL />
                    </type>
                  </variable>
                  <variable name="PaketIndex">
                    <type>
                      <INT />
                    </type>
                  </variable>
                  <variable name="FreeSlot">
                    <type>
                      <INT />
                    </type>
                  </variable>
                  <variable name="FreeSlotFound">
                    <type>
                      <BOOL />
                    </type>
                  </variable>
                  <variable name="RecivePaketID">
                    <type>
                      <WORD />
                    </type>
                  </variable>
                  <variable name="ReciveQoSLevel">
                    <type>
                      <derived name="QoS" />
                    </type>
                  </variable>
                  <variable name="TopicSize">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                  <variable name="OutData">
                    <type>
                      <BOOL />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">Output the Data, Tru if Data can be outputted</xhtml>
                    </documentation>
                  </variable>
                  <variable name="RemainingLength">
                    <type>
                      <derived name="REMAINING_LENGTH_RETURN" />
                    </type>
                  </variable>
                  <variable name="PayloadPosStart">
                    <type>
                      <UDINT />
                    </type>
                  </variable>
                  <variable name="TopicPosStart">
                    <type>
                      <UDINT />
                    </type>
                  </variable>
                  <variable name="PayloadSize">
                    <type>
                      <UDINT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">ParseIncomingPublish := 0;//if return is zero, buffer move has been done,
CounterPublishRecivedForMonitor := CounterPublishRecivedForMonitor + 1;
GVL_MQTT.ProgNum := PROG_NUM.ParsePublish;
//get remaining length
RemainingLength := GetRemainingLength(BufferIn, pos := idx,BuffSize := BufferSize);
TopicPosStart := RemainingLength.IndexAfterRemainingLength + 2;
ReciveQoSLevel := SHR(BufferIn[idx] AND 2#110,1);

TopicSize := DWORD_TO_WORD(OSCAT_BASIC.DWORD_OF_BYTE(B3:= 0, B2:= 0,
						 B1:= BufferIn[RemainingLength.IndexAfterRemainingLength],
						 B0:= BufferIn[RemainingLength.IndexAfterRemainingLength+1]));
IF RemainingLength.Error THEN
	//throw away paket on length error
	COM.MQTT_RCV_STATE := BYTE#0;//recive zurücksetzten
	//need to set size to zero, so no further parsing...
	COM.R_BUF.SIZE := 0;
	CountLengthErrors := CountLengthErrors;
	//on standard i MUST diconnect!!!
	DoDisconnect := TRUE;
	
	RETURN;
END_IF
//publish recived, size is handleable
IF ReciveQoSLevel = QoS.AtMostOnce THEN
	//Nothing to do, just out the Payload and Topic
	OutData := TRUE;
	PayloadSize := RemainingLength.RemainingLength - TopicSize - 2;//2 for Size Encoding
	PayloadPosStart := RemainingLength.IndexAfterRemainingLength + TopicSize + 2;//2 for Size Encoding
ELSE
	//get Paket ID
	RecivePaketID := DWORD_TO_WORD(OSCAT_BASIC.DWORD_OF_BYTE(B3:= 0, B2:= 0, 
		B1:= BufferIn[RemainingLength.IndexAfterRemainingLength + TopicSize + 2],//+ 2 for Topic Length
		B0:= BufferIn[RemainingLength.IndexAfterRemainingLength + TopicSize + 3]));
	//2 for size of Paket identifier
	PayloadSize := RemainingLength.RemainingLength - TopicSize - 4;//2 for size of topic  and 2 for message id
	PayloadPosStart := RemainingLength.IndexAfterRemainingLength + TopicSize + 4;//2 for size of topic and 2 for message id
	
	//QoS stuff
	FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
		IF InData[i].PaketID = RecivePaketID AND InData[i].step &lt;&gt; STEPS_IN.WAIT_DATA THEN
			PaketIndex := i;
			PaketFound := TRUE;
			
		END_IF
		IF InData[i].step = STEPS_IN.WAIT_DATA AND NOT FreeSlotFound THEN
			FreeSlot := i;
			FreeSlotFound := TRUE;
		END_IF
		IF FreeSlotFound AND PaketFound THEN
			EXIT;//exit if slot and paket found
		END_IF
	END_FOR
	IF NOT PaketFound THEN
		//Paket ist not to be awnserd --&gt; first occurence
		InData[FreeSlot].CountPubrecRepeat := 0;
		InData[FreeSlot].QoS := ReciveQoSLevel;
		InData[FreeSlot].PaketID := RecivePaketID;
		IncomingPublishOrderIndexCounter := IncomingPublishOrderIndexCounter + 1;
		InData[FreeSlot].PUBLISHOrder := IncomingPublishOrderIndexCounter;
		OutData := TRUE;
		CountRecivedPublishs := CountRecivedPublishs + 1;
	ELSE
		CountRepeatPublishRecive := CountRepeatPublishRecive + 1;
	END_IF
	CASE InData[FreeSlot].QoS OF
		QoS.AtLeastOnce:
			InData[FreeSlot].step := STEPS_IN.SEND_PUBACK;
		QoS.ExactlyOnce:
			InData[FreeSlot].step := STEPS_IN.SEND_PUBREC;
	END_CASE
END_IF

IF RemainingLength.RemainingLength &gt; (COM_CONFIG.MaxTopicElementSize * COM_CONFIG.MaxTopicLevels + COM_CONFIG.MaxPayloadSize) OR 
	TopicSize &gt; (COM_CONFIG.MaxTopicElementSize * COM_CONFIG.MaxTopicLevels) OR
	PayloadSize &gt; COM_CONFIG.MaxPayloadSize THEN
	{info 'check here if to disconnect'}
	//paket to big for my Strings, but do QoS stuff!!!! no Standard, Standard wants disconnect!
	CountToBigTopics := CountToBigTopics  + 1;
	{info 'check if last to big topic is to saved, or just take memmove'}
	(*LastToBigTopic := OSCAT_BASIC.BUFFER_TO_STRING(PT:= ADR(BufferIn[idx]), SIZE:= BufferSize,
						START:= RemainingLength.IndexAfterRemainingLength + 2,
						STOP:= RemainingLength.IndexAfterRemainingLength + TopicSize);*)
	OutData := FALSE;//reset out Data....
END_IF


IF OutData THEN
	IF MQTT_IN_OUT^.OUT.DataRecived THEN
		//Out data reserved, so push publish data to buffer...
		//NextPosReciveBuffer := GetNextPublishFreePos();
		IF PublishReciveBufferAssignment + TopicSize + PayloadSize + (2 * SIZE_PAKET_BUFFER_HEADER) &gt; RECIVE_PUBLISH_BUFFER_SIZE THEN
			//no place in buffer, must reset slot an wait for repeat, if qos 0 then paket is lost....
			{info 'check here if we want to disconect'}
			//if there is retain data stored by the broker you will end in a loop of connect and disconnect, because
			//you will allways get an to big packet....
			//only if QoS &gt; 0
			IF ReciveQoSLevel &lt;&gt; QoS.AtMostOnce THEN
				InData[FreeSlot].step := STEPS_IN.WAIT_DATA;//slot free, broker have to repeat
			END_IF
			PublishReciveBufferCountFull := PublishReciveBufferCountFull + 1;
		ELSE
			//now push data to buffer...
			//first insert topic length
			PublishReciveBuffer[PublishReciveBufferAssignment] := OSCAT_BASIC.BYTE_OF_DWORD(in:= TopicSize, N:= 3);
			PublishReciveBuffer[PublishReciveBufferAssignment + 1] := OSCAT_BASIC.BYTE_OF_DWORD(in:= TopicSize, N:= 2);
			PublishReciveBuffer[PublishReciveBufferAssignment + 2] := OSCAT_BASIC.BYTE_OF_DWORD(in:= TopicSize, N:= 1);
			PublishReciveBuffer[PublishReciveBufferAssignment + 3] := OSCAT_BASIC.BYTE_OF_DWORD(in:= TopicSize, N:= 0);
			//now copy topic
			MEM.MemMove(pSource:= ADR(BufferIn[TopicPosStart]),
				pDestination:= ADR(PublishReciveBuffer[PublishReciveBufferAssignment + SIZE_PAKET_BUFFER_HEADER]), uiNumberOfBytes:= TopicSize);
			//now point behind topic
			PublishReciveBufferAssignment := PublishReciveBufferAssignment + TopicSize + SIZE_PAKET_BUFFER_HEADER;
			//second insert payload length
			PublishReciveBuffer[PublishReciveBufferAssignment] := OSCAT_BASIC.BYTE_OF_DWORD(in:= PayloadSize, N:= 3);
			PublishReciveBuffer[PublishReciveBufferAssignment + 1] := OSCAT_BASIC.BYTE_OF_DWORD(in:= PayloadSize, N:= 2);
			PublishReciveBuffer[PublishReciveBufferAssignment + 2] := OSCAT_BASIC.BYTE_OF_DWORD(in:= PayloadSize, N:= 1);
			PublishReciveBuffer[PublishReciveBufferAssignment + 3] := OSCAT_BASIC.BYTE_OF_DWORD(in:= PayloadSize, N:= 0);
			//now copy payload
			MEM.MemMove(pSource:= ADR(BufferIn[PayloadPosStart]),
				pDestination:= ADR(PublishReciveBuffer[PublishReciveBufferAssignment + SIZE_PAKET_BUFFER_HEADER]), uiNumberOfBytes:= UDINT_TO_UINT(PayloadSize));
			PublishReciveBufferCount := PublishReciveBufferCount + 1;
			IF PublishReciveBufferCount &gt; PublishReciveBufferCountMax THEN
				PublishReciveBufferCountMax := PublishReciveBufferCount; 
			END_IF
			IF PublishReciveBufferAssignment &gt; PublishReciveBufferAssignmentMax THEN
				PublishReciveBufferAssignmentMax := PublishReciveBufferAssignment;
			END_IF
			PublishReciveBufferAssignment := PublishReciveBufferAssignment + PayloadSize + SIZE_PAKET_BUFFER_HEADER;
			//done, publish data is in buffer....
		END_IF
	ELSE
		//set termination only if we  are in the big publish buffer, if we com from the small one or
		//network buffer, we are beeing moved to dedicated buffer with termination
		IF NOT NetworkBuffer THEN //in network buffer, we have to set an termination
			IF ReciveQoSLevel = QoS.AtMostOnce THEN//if QoS zero, we need to move, because space for packet ID is missing...
				//check which is smaller, this is to be moved....
				IF TopicSize &lt; PayloadSize THEN
					//move Topic down
					MEM.MemMove(pSource:= ADR(BufferIn[TopicPosStart]), pDestination:= ADR(BufferIn[TopicPosStart - 1]), uiNumberOfBytes:= TopicSize);
					TopicPosStart := TopicPosStart - 1;//now topic resits one deeper
				ELSE
					//move Payload up
					SysMem23.SysMemMove30(pDest:= ADR(BufferIn[PayloadPosStart + 1]), pSrc:= ADR(BufferIn[PayloadPosStart]), diCount:= TO_DINT(PayloadSize));
					PayloadPosStart := PayloadPosStart + 1;//payload now resits one higher
				END_IF
			END_IF
			//now set termination, if not QoS zero, overwrite PacketID
			BufferIn[TopicPosStart + TopicSize] := 0;
		END_IF
		OutputPublish(
			PayloadSize:= PayloadSize, 
			PayloadPos:= ADR(BufferIn[PayloadPosStart]), 
			TopicSize:= TopicSize, 
			TopicPos:= ADR(BufferIn[TopicPosStart]), 
			MQTT_IN_OUT:= MQTT_IN_OUT, 
			NeedMove:= NetworkBuffer);

	END_IF
END_IF
ParseIncomingPublish := UDINT_TO_UINT(PayloadPosStart + PayloadSize);//index of next paket</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="GetNextPublishFreePos" ObjectId="3dc7a6d6-b031-4ca1-848b-e6b55ba6c2ae">
              <interface>
                <returnType>
                  <UINT />
                </returnType>
                <localVars>
                  <variable name="i">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </localVars>
                <addData>
                  <data name="http://www.3s-software.com/plcopenxml/accessmodifiers" handleUnknown="implementation">
                    <AccessModifiers Internal="true" />
                  </data>
                </addData>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">GetNextPublishFreePos := 0;
GVL_MQTT.ProgNum := PROG_NUM.GetBufferFreePos;
IF PublishReciveBufferCount = 0 THEN
	RETURN;
END_IF

//now go thrue all items to get next pos
FOR i := 0 TO PublishReciveBufferCount - 1 DO
	//get topic size
	GetNextPublishFreePos := GetNextPublishFreePos + DWORD_TO_WORD(OSCAT_BASIC.DWORD_OF_BYTE(B3:= PublishReciveBuffer[GetNextPublishFreePos],
					 B2:= PublishReciveBuffer[GetNextPublishFreePos + 1],
					 B1:= PublishReciveBuffer[GetNextPublishFreePos + 2],
					 B0:= PublishReciveBuffer[GetNextPublishFreePos + 3]));
	//go payload pos
	GetNextPublishFreePos := GetNextPublishFreePos + SIZE_PAKET_BUFFER_HEADER;
	//get payload size
	GetNextPublishFreePos := GetNextPublishFreePos + DWORD_TO_WORD(OSCAT_BASIC.DWORD_OF_BYTE(B3:= PublishReciveBuffer[GetNextPublishFreePos],
					 B2:= PublishReciveBuffer[GetNextPublishFreePos + 1],
					 B1:= PublishReciveBuffer[GetNextPublishFreePos + 2],
					 B0:= PublishReciveBuffer[GetNextPublishFreePos + 3]));
	//go go next topic pos, or free pos
	GetNextPublishFreePos := GetNextPublishFreePos + SIZE_PAKET_BUFFER_HEADER;
	
END_FOR
</xhtml>
                </ST>
              </body>
              <BuildProperties>
                <ExcludeFromBuild>true</ExcludeFromBuild>
              </BuildProperties>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="CheckLenghtBuffer" ObjectId="d2d33c09-9dff-4eb5-b512-251000170b1a">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="IdxIn">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="RecivePakteType">
                    <type>
                      <derived name="MESSAGETYPE" />
                    </type>
                  </variable>
                  <variable name="RemainingLength">
                    <type>
                      <derived name="REMAINING_LENGTH_RETURN" />
                    </type>
                  </variable>
                  <variable name="NeedBufferMove">
                    <type>
                      <BOOL />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">CheckLenghtBuffer := FALSE;

RecivePakteType := COM.R_BUF.BUFFER[IdxIn] AND 16#F0;

CASE RecivePakteType OF

	MESSAGETYPE.PUBLISH:
		IF IdxIn + 1 &gt; COM.R_BUF.SIZE THEN//1 for max size of remaining length
			CheckLenghtBuffer := TRUE;//let this, if just one ore two bytes of publish packet was recived
		ELSE
			//sizer big enough to test remaining lengt, inside testing of bytes....
			RemainingLength := GetRemainingLength(ADR(COM.R_BUF.BUFFER), pos := IdxIn, BuffSize:= COM.R_BUF.SIZE);
			//if paket to small for buffer, disconnect, remaining length is smaller then whole packet size
			IF RemainingLength.RemainingLength - 8 &gt; MaxPublishPacketSize THEN
				{info 'make this to a parameter to chose disconnect or discharge'}
				DoDisconnect := TRUE;
				CheckLenghtBuffer := TRUE;
			ELSE 
				IF (IdxIn + RemainingLength.RemainingLength &gt;= COM.R_BUF.SIZE) THEN
				//
				//move splited publish packet to buffer
					IF SplitPublishLock THEN
						//move publish packet in network recive buffer
						NeedBufferMove := TRUE;			
					ELSE
						//buffer is locked(packet is published to application) so move splited data in recive buffer for next cycle...
						SplitPublishLength := RemainingLength.RemainingLength + RemainingLength.SizeRemainingLength + 1;//one byte for fixed packed header
						SplitPublishBufferSize := COM.R_BUF.SIZE - IdxIn;;//new splited publish
						MEM.MemMove(pSource:= ADR(COM.R_BUF.BUFFER[IdxIn]), pDestination:= SplitPublishBuffer, uiNumberOfBytes:= UDINT_TO_UINT(SplitPublishBufferSize));
						//clear in Buffer
						COM.R_BUF.SIZE := 0;
						PublishSplited := TRUE;
						CheckLenghtBuffer := TRUE;
					END_IF
				END_IF 				
			END_IF
		END_IF
	MESSAGETYPE.PUBREL:
		IF IdxIn + SIZE_PUBREL &gt; COM.R_BUF.SIZE THEN
			NeedBufferMove := TRUE;
		END_IF
	MESSAGETYPE.UNSUBACK:
		IF IdxIn + SIZE_UNSUBACK &gt; COM.R_BUF.SIZE THEN
			NeedBufferMove := TRUE;
		END_IF
	MESSAGETYPE.SUBACK:
		IF IdxIn + SIZE_SUBACK &gt; COM.R_BUF.SIZE THEN
			NeedBufferMove := TRUE;
		END_IF
	MESSAGETYPE.PUBACK:
		IF IdxIn + SIZE_PUBACK &gt; COM.R_BUF.SIZE THEN
			NeedBufferMove := TRUE;
		END_IF
	MESSAGETYPE.PUBREC:
		IF IdxIn + SIZE_PUBREC &gt; COM.R_BUF.SIZE THEN
			NeedBufferMove := TRUE;
		END_IF
	MESSAGETYPE.PUBCOMP:
		IF IdxIn + SIZE_PUBCOMP &gt; COM.R_BUF.SIZE THEN
			NeedBufferMove := TRUE;
		END_IF

END_CASE

IF NeedBufferMove THEN
	MoveBufferForSplitPaket(idx:= IdxIn);
	InBufferMoved := 1;
	CheckLenghtBuffer := TRUE;
ELSE
	InBufferMoved := 0;
END_IF

IF InBufferMoved = 1 THEN
	CountWaitForRestOfPaket := CountWaitForRestOfPaket + 1;
END_IF

IF CountWaitForRestOfPaket &gt; 1000 THEN
	//waited long for rest of paket, so reset...	
	//unknown paket, reset buffer....
	//standard wants to disconnect....
	{info 'TODO:check to make disconnect as parameter'}
	DoDisconnect := TRUE;
	COM.R_BUF.SIZE := 0;	
	//unknown paket recived
	NotKnownPaket := COM.R_BUF.BUFFER[0] AND 16#F0;
	//allway reset recive!
	COM.MQTT_RCV_STATE := BYTE#0;//recive zurücksetzten
	COM.R_BUF.SIZE := 0;
	CountWaitForRestOfPaket := 0;
	CountResetBufferIn := CountResetBufferIn + 1;
END_IF</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="FB_Exit" ObjectId="b9c05d0c-ef6e-4249-9bbd-be68de915780">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="bInCopyCode">
                    <type>
                      <BOOL />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml"> TRUE: the exit method is called in order to leave the instance which will be copied afterwards (online change). </xhtml>
                    </documentation>
                  </variable>
                </inputVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">destroy();
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="destroy" ObjectId="4ec73c21-a461-466b-8611-c64366e7705a">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <localVars>
                  <variable name="iu">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">SplitTopic.destroy();
GVL_MQTT.ProgNum := PROG_NUM.DESTROY_HANDLE_MQTT;
{warning disable C0033}
SysMem23.SysMemFree(dwAddress:= SplitPublishBuffer, dwSize:= MaxPublishPacketSize + SPLIT_PUBLISH_BUFFER_ADDITIONAL_RAM);
{warning restore C0033}
DynMemUsagePointer^ := DynMemUsagePointer^ - (MaxPublishPacketSize + SPLIT_PUBLISH_BUFFER_ADDITIONAL_RAM);
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="OutputPublish" ObjectId="41ef459f-dc94-4b40-9ac4-ceeadc73dff2">
              <interface>
                <inputVars>
                  <variable name="PayloadSize">
                    <type>
                      <UDINT />
                    </type>
                  </variable>
                  <variable name="PayloadPos">
                    <type>
                      <pointer>
                        <baseType>
                          <BYTE />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">be aware, don't use network buffer, IP_CONTROL may change content</xhtml>
                    </documentation>
                  </variable>
                  <variable name="TopicSize">
                    <type>
                      <UDINT />
                    </type>
                  </variable>
                  <variable name="TopicPos">
                    <type>
                      <pointer>
                        <baseType>
                          <BYTE />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">be aware, don't use network buffer, IP_CONTROL may change content</xhtml>
                    </documentation>
                  </variable>
                  <variable name="MQTT_IN_OUT">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="MQTT_IN_OUT" />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                  <variable name="NeedMove">
                    <type>
                      <BOOL />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">data must be moved from network buffer to local buffer</xhtml>
                    </documentation>
                  </variable>
                </inputVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">//here make everything to give out publish, and test if topic fits to my borders...
IF SplitTopic.NewTopic(in:= TopicPos, test := FALSE, SizeOfString:= UDINT_TO_UINT(TopicSize)) = TOPIC_VALID.TOPIC_NOT_VALID THEN
	//topic is not in my borders so throw away data...
	{info 'configure to disconnect?'}
	{ info 'make count var...'}
	CountSplitTopicSizeExceeded := CountSplitTopicSizeExceeded + 1;
	RETURN;
END_IF
//QoS stuff shold already be done, so ignor missing data
IF NeedMove THEN
	MEM.MemMove(pSource:= TopicPos, pDestination:= ADR(BufferTopic), uiNumberOfBytes:= UDINT_TO_UINT(TopicSize));
	MEM.MemMove(pSource:= PayloadPos, pDestination:= ADR(BufferPayload), uiNumberOfBytes:= UDINT_TO_UINT(PayloadSize));//can reduse payload size, because is only done if data coms freom network buffer
	BufferTopic[TopicSize] := 0;//set termination
	MQTT_IN_OUT^.OUT.MqttPayload := ADR(BufferPayload);
	MQTT_IN_OUT^.OUT.MqttTopic := ADR(BufferTopic);
ELSE
	MQTT_IN_OUT^.OUT.MqttPayload := PayloadPos;
	MQTT_IN_OUT^.OUT.MqttTopic := TopicPos;
END_IF

MQTT_IN_OUT^.OUT.MqttPayloadSize := PayloadSize;

MQTT_IN_OUT^.OUT.DataRecived := TRUE;
MQTT_IN_OUT^.OUT.MessageType := MESSAGETYPE.PUBLISH;
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="MergeSplitedPublish" ObjectId="9d396c27-f37d-4dd3-95cd-3c260fb5beb7">
              <interface>
                <inputVars>
                  <variable name="MQTT_IN_OUT">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="MQTT_IN_OUT" />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="BytesToMove">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">//move every new data to publish recive buffer untill all data is recived
BytesToMove := TO_UINT(MIN(com.R_BUF.SIZE, SplitPublishLength - SplitPublishBufferSize));
MEM.MemMove(pSource:= ADR(COM.R_BUF.BUFFER), pDestination:= ADR(SplitPublishBuffer[SplitPublishBufferSize]), uiNumberOfBytes:= BytesToMove);
SplitPublishBufferSize := SplitPublishBufferSize + BytesToMove;
IF SplitPublishBufferSize &gt;= SplitPublishLength THEN
	SplitPublishLock := TRUE;
	PublishSplited := FALSE;
	//ParsePublish will insert string termination if no network buffer
	ParseIncomingPublish(
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	idx:= 0, 
	BufferIn:= SplitPublishBuffer, 
	NetworkBuffer:= FALSE,
	BufferSize:= SplitPublishBufferSize);
END_IF
//check if there is more data in buffer --&gt; new packet
IF BytesToMove &lt; COM.R_BUF.SIZE THEN
	//move buffer and set new size...
	MEM.MemMove(pSource:= ADR(COM.R_BUF.BUFFER[BytesToMove]), pDestination:= ADR(COM.R_BUF.BUFFER),
				uiNumberOfBytes:= COM.R_BUF.SIZE - BytesToMove);
	COM.R_BUF.SIZE := COM.R_BUF.SIZE - BytesToMove;
ELSE
	//clear buffer
	COM.R_BUF.SIZE := 0;
	COM.MQTT_RCV_STATE := BYTE#0;//recive zurücksetzten	
END_IF</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="Publish" ObjectId="69dd8b32-66a3-4c6d-a9c4-38a21807fc8e">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="data">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="DATA_TO_BROKER" />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="i">
                    <type>
                      <INT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">Publish := FALSE;
FOR i := 0 TO QoS_BUFFER_SIZE - 1 DO
	IF OutData[i].step = STEPS_OUT.WAIT_DATA THEN
		OutData[i].InDataFromFb := data;//set Data
		//Pakte id = slot + 1....
		OutData[i].InDataFromFb^.PaketId := INT_TO_UINT(i + 1);
		OutgoingPublishOrderIndexCounter := OutgoingPublishOrderIndexCounter + 1;
		OutData[i].PUBLISHOrder :=  OutgoingPublishOrderIndexCounter;
		OutData[i].step := STEPS_OUT.SEND_PUBLSIH;
		CountSendedPublishs := CountSendedPublishs + 1;
		CounterPublishSendForMonitor := CounterPublishSendForMonitor + 1;
		OutData[i].PUBRELRepeatCounter := 0;
		Publish := TRUE;
		EXIT;
	END_IF
END_FOR</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>de40940d-72fb-4911-9e82-a78a5e144b68</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="InsertSplitPayload" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="payload">
              <type>
                <pointer>
                  <baseType>
                    <BYTE />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">payload to insert....</xhtml>
              </documentation>
            </variable>
            <variable name="len">
              <type>
                <UDINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">length of payload</xhtml>
              </documentation>
            </variable>
            <variable name="buff">
              <type>
                <pointer>
                  <baseType>
                    <BYTE />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">address to buffer</xhtml>
              </documentation>
            </variable>
            <variable name="pos">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Start to insert</xhtml>
              </documentation>
            </variable>
            <variable name="size">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">size of buffer</xhtml>
              </documentation>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="state">
              <type>
                <derived name="INSERT_SPLIT_RETURN" />
              </type>
            </variable>
            <variable name="new_pos">
              <type>
                <UINT />
              </type>
            </variable>
          </outputVars>
          <localVars>
            <variable name="step">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="akt_pos">
              <type>
                <UDINT />
              </type>
            </variable>
          </localVars>
          <tempVars>
            <variable name="bytes_to_send">
              <type>
                <UINT />
              </type>
            </variable>
          </tempVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">//always make my output valid
new_pos := pos;

IF step = 0 THEN
	step := 10;//start insert...
END_IF

//don't use case, so save a cyle...
IF step = 10 THEN
	//evaluate if we have to split payload....
	IF size - pos &lt; len THEN
		step := 20;
		akt_pos := 0;
	ELSE
		//here no split needed
		MEM.MemMove(pSource:= payload, pDestination:= ADR(buff[new_pos]), uiNumberOfBytes:= UDINT_TO_UINT(len));
		new_pos := UDINT_TO_UINT(new_pos + len);//new pos for output
		state := INSERT_SPLIT_RETURN.INSERT_DONE;
		step := 0;
	END_IF
END_IF

IF step = 20 THEN
	//now do split payload...
	bytes_to_send := UDINT_TO_UINT(MIN(size - new_pos, len - akt_pos));
	MEM.MemMove(pSource:= ADR(payload[akt_pos]), pDestination:= ADR(buff[new_pos]), uiNumberOfBytes:= bytes_to_send);
	akt_pos := akt_pos + bytes_to_send;
	new_pos := new_pos +  bytes_to_send;
	IF akt_pos + 1 &gt;= len THEN
		//send done
		state := INSERT_SPLIT_RETURN.INSERT_DONE;
		step := 0;
	ELSE
		state := INSERT_SPLIT_RETURN.INSERT_PENDING;
	END_IF
END_IF
</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="reset" ObjectId="05ae8f49-4f21-4727-8495-50c84c2a2285">
              <interface />
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">step := 0;</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>22733c41-86e3-41ca-bf60-527fc6a5bc73</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="InsertSplitTopic" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="topic">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">topic to insert....</xhtml>
              </documentation>
            </variable>
            <variable name="len">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">length of topic</xhtml>
              </documentation>
            </variable>
            <variable name="buff">
              <type>
                <pointer>
                  <baseType>
                    <BYTE />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">address to buffer</xhtml>
              </documentation>
            </variable>
            <variable name="pos">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Start to insert</xhtml>
              </documentation>
            </variable>
            <variable name="size">
              <type>
                <UINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">size of buffer</xhtml>
              </documentation>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="state">
              <type>
                <derived name="INSERT_SPLIT_RETURN" />
              </type>
            </variable>
            <variable name="new_pos">
              <type>
                <UINT />
              </type>
            </variable>
          </outputVars>
          <localVars>
            <variable name="step">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="akt_pos">
              <type>
                <UINT />
              </type>
            </variable>
          </localVars>
          <tempVars>
            <variable name="bytes_to_send">
              <type>
                <UINT />
              </type>
            </variable>
          </tempVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">//always make my output valid
new_pos := pos;

IF step = 0 THEN
	step := 10;//start insert...
END_IF

//don't use case, so save a cyle...
IF step = 10 THEN
	//check if buffer size is enogh for header
	IF size - new_pos &lt; 2 THEN
		state := INSERT_SPLIT_RETURN.INSERT_ERROR;
		RETURN;
	END_IF
	buff[new_pos]:= OSCAT_BASIC.BYTE_OF_DWORD(in:= len, N:= 1);
	buff[new_pos+1]:= OSCAT_BASIC.BYTE_OF_DWORD(in:= len, N:= 0);
	new_pos := new_pos + 2;
	step := 20;
END_IF

IF step = 20 THEN
	//evaluate if we have to split topic....
	IF size - pos &lt; len THEN
		step := 30;
		akt_pos := 0;
	ELSE
		//here no split needed
		MEM.MemMove(pSource:= topic, pDestination:= ADR(buff[new_pos]), uiNumberOfBytes:= len);
		new_pos := new_pos + len;//new pos for output
		state := INSERT_SPLIT_RETURN.INSERT_DONE;
		step := 0;
	END_IF
END_IF

IF step = 30 THEN
	//now do split topic...
	bytes_to_send := MIN(size - new_pos, len - akt_pos);
	MEM.MemMove(pSource:= ADR(topic^[akt_pos]), pDestination:= ADR(buff[new_pos]), uiNumberOfBytes:= bytes_to_send);
	akt_pos := akt_pos + bytes_to_send;
	new_pos := new_pos +  bytes_to_send;
	IF akt_pos + 1 &gt;= len THEN
		//send done
		state := INSERT_SPLIT_RETURN.INSERT_DONE;
		step := 0;
	ELSE
		state := INSERT_SPLIT_RETURN.INSERT_PENDING;
	END_IF
END_IF
</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="reset" ObjectId="1fcde2a6-7eb6-4266-9d66-95d21574ca96">
              <interface />
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">step := 0;</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>86a50c54-22c9-433f-91fe-823ead6df5b5</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="MQTT_CONTROL" pouType="functionBlock">
        <interface>
          <inOutVars>
            <variable name="COM">
              <type>
                <derived name="MQTT_COM" />
              </type>
            </variable>
            <variable name="INFO">
              <type>
                <derived name="MQTT_INFO" />
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="IP_C">
              <type>
                <derived name="IP_C" />
              </type>
            </variable>
            <variable name="URL_DATA">
              <type>
                <derived name="url" />
              </type>
            </variable>
            <variable name="IPC">
              <type>
                <derived name="CommonTypesAndFunctions.IP_CONTROL_TLS" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">DNS_CLIENT : DNS_CLIENT;</xhtml>
              </documentation>
            </variable>
            <variable name="sResultIP">
              <type>
                <string />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> IP-Address behind hostname</xhtml>
              </documentation>
            </variable>
            <variable name="rtsResult">
              <type>
                <derived name="RTS_IEC_RESULT" />
              </type>
            </variable>
            <variable name="step">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="snd_step">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="TON_WAIT">
              <type>
                <derived name="OSCAT_BASIC.TON" />
              </type>
            </variable>
            <variable name="last_step">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="idx1">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="connectToLocalhost">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="staticIP">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="timeout1">
              <type>
                <TIME />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">idx2 : INT;
idx3 : INT;
dw_tmp : DWORD;</xhtml>
              </documentation>
            </variable>
            <variable name="timeout2">
              <type>
                <TIME />
              </type>
            </variable>
            <variable name="ip_c_red_disable">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="remaining_length">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="nop">
              <type>
                <INT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">
	LOG_MSG : LOG_MSG;
	_debug_enable : BOOL := TRUE;
	</xhtml>
              </documentation>
            </variable>
            <variable name="S_BUF">
              <type>
                <derived name="NETWORK_BUFFER" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">******************************************************************************
here all TLS Stuff</xhtml>
              </documentation>
            </variable>
            <variable name="R_BUF">
              <type>
                <derived name="NETWORK_BUFFER" />
              </type>
            </variable>
            <variable name="TLSConnection">
              <type>
                <derived name="RTS_IEC_HANDLE" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">******************************************************************************
RTSResult: RTS_IEC_RESULT;</xhtml>
              </documentation>
            </variable>
          </localVars>
          <tempVars>
            <variable name="WillTopic">
              <type>
                <string length="255" />
              </type>
            </variable>
          </tempVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">IF com.ERROR_C &lt;&gt; 0 THEN
 step := step;
END_IF 
//init Pointers


CASE step OF

00:	IF COM.MQTT_CON THEN

		timeout1 := MAX(T#10S,COM.TIMEOUT);
		timeout2 := timeout1 + T#1s;
		INFO.MQTT_ERROR := '';
		COM.ERROR_C := DWORD#0;
		COM.ERROR_T := BYTE#0;
		URL_DATA := STRING_TO_URL(STR:=COM.MQTT_URL,DEFAULT_PROTOCOL:='',DEFAULT_PATH:='/');
		IF SysStr23.SysStrCmpI(sString1:= OSCAT_BASIC.LOWERCASE(str:=URL_DATA.DOMAIN ), sString2:= 'localhost') = 0   THEN
			connectToLocalhost := TRUE;
		ELSE
			connectToLocalhost := FALSE;
		END_IF
		IF OSCAT_NETWORK.IP4_DECODE(str:= URL_DATA.DOMAIN) &gt; 0 THEN
			sResultIP := URL_DATA.DOMAIN;
			staticIP := TRUE;
		ELSE
			staticIP := FALSE;
		END_IF
		IF connectToLocalhost OR staticIP THEN
			//jump to connect
			step := 20;
		ELSE
			//get ip by dns
			step := 10;
		END_IF
	END_IF;

10:
	IF CommonTypesAndFunctions.ResolveIPAddr(sHost:= URL_DATA.DOMAIN, sIPResult:= ADR(sResultIP)) = CmpErrors.Errors.ERR_OK THEN
		step := 20;
	ELSE
		step := 980;
	END_IF

20:	(* MQTT Steuerkanal einrichten *)
	IF URL_DATA.PORT = WORD#0 THEN
		URL_DATA.PORT := WORD#1883; (* Standard Port *)
	END_IF;
	IP_C.C_PORT := URL_DATA.PORT; (* Portnummer eintragen *)
	IF connectToLocalhost THEN
		IP_C.C_IP := IP4_DECODE('127.0.0.1'); (* IP eintragen, localhost *)
	ELSE
		IP_C.C_IP := IP4_DECODE(sResultIP); (* IP eintragen *)
	END_IF
  	
	IP_C.C_MODE := BYTE#0; (* Mode: TCP+ACTIV+PORT *)
  	IP_C.TIME_RESET := TRUE; (* Zeitueberwachung rücksetzen *)
  	IP_C.C_ENABLE := TRUE; (* Verbindungsaufbau freigeben *)
  	IP_C.R_OBSERVE := FALSE; (* Empfangsueberwachung *)
	COM.R_BUF.SIZE := UINT#0;
	COM.MQTT_RCV_STATE := BYTE#0;
	step := 30;
	

30:	 IF IP_C.C_STATE = BYTE#255 THEN
		COM.S_BUF.BUFFER[0] := MESSAGETYPE.CONNECT;
		COM.S_BUF.BUFFER[1] := 0;//Header length, cal at least
		COM.S_BUF.BUFFER[2] := 0;//Variable Header length
		COM.S_BUF.BUFFER[3] := 4;//Variable Header length
		COM.S_BUF.BUFFER[4] := OSCAT_BASIC.CODE(STR:= 'M', POS:= 1);//Protokoll name
		COM.S_BUF.BUFFER[5] := OSCAT_BASIC.CODE(STR:= 'Q', POS:= 1);//Protokoll name
		COM.S_BUF.BUFFER[6] := OSCAT_BASIC.CODE(STR:= 'T', POS:= 1);//Protokoll name
		COM.S_BUF.BUFFER[7] := OSCAT_BASIC.CODE(STR:= 'T', POS:= 1);//Protokoll name
		COM.S_BUF.BUFFER[8] := 4; //Protokoll Level
		COM.S_BUF.BUFFER[9] := 2#00110110;//Connect flags
							   //|||||||+-Reserved
							   //||||||+--Clean Session
							   //|||||+---Will Flag
							   //|||++----Will QoS
							   //||+------Will Retain
							   //|+-------Password Flag
							   //+--------UserNameFlag
		COM.S_BUF.BUFFER[10] := OSCAT_BASIC.BYTE_OF_DWORD(in:= MyConstants.KEEP_ALIVE_TIME, N:= 1);//keep alive MSB
		COM.S_BUF.BUFFER[11] := OSCAT_BASIC.BYTE_OF_DWORD(in:= MyConstants.KEEP_ALIVE_TIME, N:= 0);//keep alive LSB
		//idx1 points to next free byte
		//now put in client id 
		idx1 := InsertStringToBufferAndLength(Str:= ADR(COM.CLIENT_ID), buff:= ADR(COM.S_BUF.BUFFER), pos:= 12(*, size:= OSCAT_NETWORK.Constants.NETWORK_BUFFER_LONG_SIZE*));
		//now put in will topic
		WillTopic := Standard.CONCAT(STR1:= COM.CLIENT_ID, STR2:= Standard.CONCAT(STR1:= '/', STR2:= COM.CLIENT_WILL_TOPIC));
		idx1 := InsertStringToBufferAndLength(Str:= ADR(WillTopic), buff:= ADR(COM.S_BUF.BUFFER), pos:= idx1(*, size:= OSCAT_NETWORK.Constants.NETWORK_BUFFER_LONG_SIZE*));
		//now put in will message
		//IF Standard.LEN(STR:= COM.CLIENT_WILL_MESSAGE_DEAD) &gt; 0 THEN
		idx1 := InsertStringToBufferAndLength(Str:= ADR(COM.CLIENT_WILL_MESSAGE_DEAD), buff:= ADR(COM.S_BUF.BUFFER), pos:= idx1(*, size:= OSCAT_NETWORK.Constants.NETWORK_BUFFER_LONG_SIZE*));
		//END_IF
		//if user is given, set user bit an insert username
		IF Standard.LEN(STR:= COM.BROKER_USER) &gt; 0 THEN
			COM.S_BUF.BUFFER[8] := COM.S_BUF.BUFFER[8] OR 2#10000000;
			//now put in user name
			idx1 := InsertStringToBufferAndLength(Str:= ADR(COM.BROKER_USER), buff:= ADR(COM.S_BUF.BUFFER), pos:= idx1(*, size:= OSCAT_NETWORK.Constants.NETWORK_BUFFER_LONG_SIZE*));
		END_IF
		//if password is given, set password bit an insert username
		IF Standard.LEN(STR:= COM.BROKER_PASSWORD) &gt; 0 THEN
			COM.S_BUF.BUFFER[8] := COM.S_BUF.BUFFER[8] OR 2#1000000;
			//now put in user name
			idx1 := InsertStringToBufferAndLength(Str:= ADR(COM.BROKER_PASSWORD), buff:= ADR(COM.S_BUF.BUFFER), pos:= idx1(*, size:= OSCAT_NETWORK.Constants.NETWORK_BUFFER_LONG_SIZE*));
		END_IF
		//now cal packet lengt and insert remaining legth
		remaining_length := idx1 - 2;
		DoRemainingLength(buffer:= ADR(com.S_BUF.BUFFER), RemainingLength:= remaining_length);
		//now send data
		COM.S_BUF.SIZE := idx1;
		step := 40;//wait for CONNACK
	END_IF
	
		
40:	//IF COM.MQTT_RCV_STATE = BYTE#1 THEN//recived packet
	IF COM.R_BUF.SIZE &gt; 0 THEN//recived packet
		IF COM.R_BUF.BUFFER[0] &lt;&gt; MESSAGETYPE.CONNACK THEN
			step := 700;//close connection
		ELSE//get connack packet
			IF COM.R_BUF.BUFFER[3] = 0 THEN
				//connection accepted
				INFO.MQTT_CONNECTED := TRUE;
				COM.R_BUF.SIZE := 0;
				COM.MQTT_RCV_STATE := BYTE#0;
				step := 300;
			ELSE
				step := 700;//close connection
			END_IF
		END_IF
		
	END_IF


(* ================================================== *)

300:	step := UINT_TO_INT(SEL(COM.MQTT_CON,700,310)); (* Schritt-Selektion *)

310:	step := 300; (* dummy step *)

(* ================================================== *)

700: (* COM_QUIT *)
	//INFO.MQTT_CONNECTED := FALSE;
	IF COM.MQTT_ABORT THEN
		step := 980;//close without disconnect packet
		COM.MQTT_ABORT := FALSE;
	ELSE
		COM.S_BUF.BUFFER[0] := MESSAGETYPE.DISCONNECT; (* 0x01 COM_QUIT mqtt_close *)
		COM.S_BUF.BUFFER[1] := 0;
		COM.S_BUF.SIZE := UINT#2; (* Sendelänge eintragen *)
		
		ip_c_red_disable := TRUE;
		step := 710;
	END_IF
710:	IF COM.S_BUF.SIZE = BYTE#0 THEN (* letztes Paket gesendet?*)
		step := 980;
	END_IF;

(* ================================================== *)

980:IP_C.C_ENABLE := FALSE; (* MQTT Steuerkanal schliessen *)
	ip_c_red_disable := FALSE;
	INFO.MQTT_CONNECTED := FALSE;
	COM.MQTT_CON := FALSE;
	COM.S_BUF.SIZE := UINT#0;
	COM.R_BUF.SIZE := UINT#0;
	snd_step := 0;
	step := 990;
	(*####################  DEBUG-MESSAGE  ###################################*)
	(*IF _debug_enable THEN
		LOG_CL.NEW_MSG := 'QUIT: ERROR CODE &gt;~1&lt; TYPE &gt;~2&lt;';
		LOG_CL.PRINTF[1] := DWORD_TO_STRH(COM.ERROR_C);
		LOG_CL.PRINTF[2] := BYTE_TO_STRING(COM.ERROR_T);
		LOG_MSG();
	END_IF;*)
	(*########################################################################*)

990:IF IP_C.C_STATE = BYTE#0 THEN
		step := 0;
	END_IF;

END_CASE;

(* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)
IF step &gt; 40 THEN
	IF COM.R_BUF.SIZE &gt;= UINT#1 THEN (* Daten wurden empfangen ? neue kommunikation*)
		
		COM.MQTT_RCV_STATE := BYTE#1;
		
	END_IF;
END_IF;
(* automatisches Datensenden *)

CASE snd_step OF

00:	IF step &gt; 40 THEN
	
		IF COM.S_BUF.SIZE &gt; UINT#0 THEN
	
		    (*####################  DEBUG-MESSAGE  ###################################*)
	        (*IF _debug_enable THEN
	          LOG_CL.NEW_MSG := 'SND: size &gt;~1&lt;';
	          LOG_CL.PRINTF[1] := UINT_TO_STRING(COM.S_BUF.SIZE);
	          LOG_MSG();
	        END_IF;*)
	        (*########################################################################*)

			snd_step := 10;
		END_IF;		
	END_IF;

10:	IF COM.S_BUF.SIZE = UINT#0 THEN (* warten bis alle daten gesendet sind *)
		snd_step := 0;
	END_IF;

END_CASE;

(* Globale Fehlerbehandlung für Haupt-Routine *)
IF COM.ERROR_T = BYTE#0 AND step &gt; 20 THEN (* noch kein Fehler gespeichert und Hauptroutine aktiv *)
	IF IP_C.ERROR &gt; DWORD#0 AND IP_C.C_ENABLE AND NOT IP_C.TIME_RESET THEN  (* IP Control *)
		IF ip_c_red_disable = FALSE OR IP_C.ERROR &lt;&gt; DWORD#16#FD000000 THEN
			COM.ERROR_C := IP_C.ERROR;
			COM.ERROR_T := BYTE#2;
			step := 980;
		END_IF;
	END_IF;
END_IF;

IF TON_WAIT.Q THEN (* Ablaufstörung - Schrittkette *)
	COM.ERROR_C := INT_TO_DWORD(step); (* aktuellen Schritt eintragen *)
	COM.ERROR_T := BYTE#5;
	step := 980;
END_IF;

(* ######################################################## *)

//DNS_CLIENT(IP_C:=IP_C, S_BUF:=COM.S_BUF, R_BUF:=COM.R_BUF, DOMAIN:=URL_DATA.DOMAIN, IP4_DNS:= COM.DNS_IP4, ACTIVATE:=step=10); (* DNS-Client *)
IPC(IP:= DWORD#0, PORT:= WORD#0 , TIME_OUT:= timeout1, IP_C:= IP_C, S_BUF:= COM.S_BUF, R_BUF:= COM.R_BUF, TLS_CONFIG_IN := COM.TLS_CONFIG, useTls:= COM.TLS); (* MQTT Steuerkanal *)

TON_WAIT(IN:=step = last_step AND step &gt; 0,PT:=timeout2);
last_step := step;


(* revision history


*)</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>9b642721-ce73-4258-9e15-8e2406aa0c86</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="MQTTBase" pouType="functionBlock">
        <interface>
          <localVars>
            <variable name="MQTT_IN_OUT">
              <type>
                <pointer>
                  <baseType>
                    <derived name="MQTT_IN_OUT" />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="DbPointerIo">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Set to true if get DB Pointer </xhtml>
              </documentation>
            </variable>
            <variable name="TokenRequested">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="RTrig">
              <type>
                <derived name="r_trig" />
              </type>
            </variable>
            <variable name="COM_CONFIG">
              <type>
                <derived name="COM_CONFIG" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">config for boot up</xhtml>
              </documentation>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">IF not DbPointerIo THEN RETURN; END_IF
MQTT_IN_OUT^.FB_NO_AUTO := MQTT_IN_OUT^.FB_NO_AUTO + 1;</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="SetMqttInOut" ObjectId="3e841b5d-b781-44dd-ba86-78e29089f6be">
              <interface>
                <returnType>
                  <INT />
                </returnType>
                <inputVars>
                  <variable name="MQTT_IN_OUT">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="MQTT_IN_OUT" />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                </inputVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">THIS^.MQTT_IN_OUT := MQTT_IN_OUT;
DbPointerIo := TRUE;</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="CheckToken" ObjectId="d147036f-655b-41a3-9039-69fc31885cc5">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">
IF MQTT_IN_OUT^.FB_NO_AUTO =  MQTT_IN_OUT^.FB_NO_AUTO_TOKEN AND TokenRequested THEN
	CheckToken := TRUE;

END_IF
IF MQTT_IN_OUT^.FB_NO_AUTO =  MQTT_IN_OUT^.FB_NO_AUTO_TOKEN AND NOT TokenRequested THEN
	MQTT_IN_OUT^.FB_NO_AUTO_TOKEN := MQTT_IN_OUT^.FB_NO_AUTO_TOKEN + 1;	
END_IF
</xhtml>
                </ST>
              </body>
              <BuildProperties>
                <ExcludeFromBuild>true</ExcludeFromBuild>
              </BuildProperties>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="RequestToken" ObjectId="c76fd038-87b5-4695-8477-ac9be3fd0c0e">
              <interface>
                <inputVars>
                  <variable name="request">
                    <type>
                      <BOOL />
                    </type>
                  </variable>
                </inputVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">RTrig(CLK:= request);
//IF RTrig.Q THEN
IF request THEN
	TokenRequested := TRUE;
END_IF</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="ReleaseToken" ObjectId="61892de8-a34d-4b3a-82aa-a1e5b61fdca4">
              <interface />
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">IF MQTT_IN_OUT^.FB_NO_AUTO =  MQTT_IN_OUT^.FB_NO_AUTO_TOKEN THEN
	MQTT_IN_OUT^.FB_NO_AUTO_TOKEN := MQTT_IN_OUT^.FB_NO_AUTO_TOKEN + 1;
END_IF
TokenRequested := FALSE;</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>22db369a-9de1-444e-be59-cbfd328e69c6</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="MQTTPublish" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="Topic">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">here your topic</xhtml>
              </documentation>
            </variable>
            <variable name="PayloadString">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">here the payload String</xhtml>
              </documentation>
            </variable>
            <variable name="PublishAsString">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">set this to true to bublish a string, else the data is excpected on Payload</xhtml>
              </documentation>
            </variable>
            <variable name="Payload">
              <type>
                <pointer>
                  <baseType>
                    <BYTE />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">binary payload</xhtml>
              </documentation>
            </variable>
            <variable name="PayloadLength">
              <type>
                <UDINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">length of binary payload</xhtml>
              </documentation>
            </variable>
            <variable name="QoSIn">
              <type>
                <derived name="QoS" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">QoS Level</xhtml>
              </documentation>
            </variable>
            <variable name="MRetain">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Message is retain?</xhtml>
              </documentation>
            </variable>
            <variable name="send">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">send on positiv edge, be aware, don't change payload an topic until send is done!!!</xhtml>
              </documentation>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="done">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">sucsessfull transmittet</xhtml>
              </documentation>
            </variable>
            <variable name="sendActive">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">trying to send</xhtml>
              </documentation>
            </variable>
            <variable name="SendTimeout">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Timout of sendding while connection io --&gt; to much load</xhtml>
              </documentation>
            </variable>
            <variable name="CountSend">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">count of publish send sucsessfull</xhtml>
              </documentation>
            </variable>
          </outputVars>
          <localVars>
            <variable name="requestToSend">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="TriggerEdge">
              <type>
                <derived name="Standard.R_TRIG" />
              </type>
            </variable>
            <variable name="WasSendet">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">paket gone out</xhtml>
              </documentation>
            </variable>
            <variable name="TimeToResponse">
              <type>
                <derived name="CAA.TICK" />
              </type>
            </variable>
            <variable name="LastSend">
              <type>
                <derived name="CAA.TICK" />
              </type>
            </variable>
            <variable name="MyOutData">
              <type>
                <derived name="DATA_TO_BROKER" />
              </type>
            </variable>
            <variable name="DUP">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">retry bit</xhtml>
              </documentation>
            </variable>
            <variable name="SendTimeOutTime">
              <type>
                <derived name="ton" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">timeout timer</xhtml>
              </documentation>
            </variable>
          </localVars>
          <addData>
            <data name="http://www.3s-software.com/plcopenxml/pouinheritance" handleUnknown="implementation">
              <Inheritance>
                <Extends>MQTTBase</Extends>
              </Inheritance>
            </data>
          </addData>
          <documentation>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">be aware, don't change payload an topic until send is done!!!
check pointer if valid
</xhtml>
          </documentation>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">SUPER^();
//if not config, then leave, do this after super so we calc correct FB numbers
IF NOT DbPointerIo THEN RETURN; END_IF;
GVL_MQTT.ProgNum := PROG_NUM.Publish;
TriggerEdge(CLK:= send AND NOT requestToSend AND MQTT_IN_OUT^.BROKER_CONNECTED);

IF NOT MQTT_IN_OUT^.BROKER_CONNECTED THEN
	//no connection, reset
	WasSendet := FALSE;
	IF requestToSend THEN
		DUP := TRUE;
	END_IF
	
END_IF

done := FALSE;

IF TriggerEdge.Q THEN
	requestToSend := TRUE;
END_IF

IF requestToSend AND NOT WasSendet THEN
	//try to publish
	MyOutData.PaketData.MqttTopicLength := CommonTypesAndFunctions.LEN(Topic);
	//don't sent zero lengt topics...
	IF  MyOutData.PaketData.MqttTopicLength &gt; 0 THEN
		MyOutData.PaketData.FbId := MQTT_IN_OUT^.FB_NO_AUTO;
		MyOutData.PaketData.MessageType := MESSAGETYPE.PUBLISH;
		MyOutData.PaketData.MessageRetain := MRetain;
		MyOutData.PaketData.MessageQoS := QoSIn;
		IF PublishAsString THEN
			MyOutData.PaketData.MqttPayloadLength := CommonTypesAndFunctions.LEN(PayloadString);
			MyOutData.PaketData.MqttPayload := PayloadString;
		ELSE
			MyOutData.PaketData.MqttPayloadLength := PayloadLength;
			MyOutData.PaketData.MqttPayload := Payload;
		END_IF
		MyOutData.PaketData.MqttTopic := Topic;
		MyOutData.PaketData.DUP := DUP;
		WasSendet := TRUE;
		LastSend := TICKS.GetTick(xDummy:= TRUE);
	ELSE
		{info 'check if we want to diplay topic error'}
		;
	END_IF
	IF MQTT_IN_OUT^.handleFB^.Publish(data:=ADR(MyOutData)) THEN
		WasSendet := TRUE;
	END_IF
END_IF


(*
RequestToken(request:= requestToSend AND NOT WasSendet);


//IF requestToSend AND NOT WasSendet AND MQTT_IN_OUT^.InFree AND CheckToken(request:= )THEN

IF requestToSend AND NOT WasSendet AND CheckToken() AND MQTT_IN_OUT^.InFree AND MQTT_IN_OUT^.BROKER_CONNECTED THEN
	//try to publish
	MyOutData.PaketData.MqttTopicLength := CommonTypesAndFunctions.LEN(Topic);
	//don't sent zero lengt topics...
	IF  MyOutData.PaketData.MqttTopicLength &gt; 0 THEN
		//send free
		MQTT_IN_OUT^.IN := ADR(MyOutData);
		MQTT_IN_OUT^.InFree := FALSE;
		MyOutData.PaketData.FbId := MQTT_IN_OUT^.FB_NO_AUTO;
		MyOutData.PaketData.MessageType := MESSAGETYPE.PUBLISH;
		MyOutData.PaketData.MessageRetain := MRetain;
		MyOutData.PaketData.MessageQoS := QoSIn;
		IF PublishAsString THEN
			MyOutData.PaketData.MqttPayloadLength := CommonTypesAndFunctions.LEN(PayloadString);
			MyOutData.PaketData.MqttPayload := PayloadString;
		ELSE
			MyOutData.PaketData.MqttPayloadLength := PayloadLength;
			MyOutData.PaketData.MqttPayload := Payload;
		END_IF
		MyOutData.PaketData.MqttTopic := Topic;
		MyOutData.PaketData.DUP := DUP;
		WasSendet := TRUE;
		LastSend := TICKS.GetTick(xDummy:= TRUE);
	ELSE
		{info 'check if we want to diplay topic error'}
		;
	END_IF
		ReleaseToken();
END_IF
*)
//place behinde send, so leave "Token" to rest....
IF MyOutData.PaketData.SendSucsess THEN //scusses set by HANDLE_MQTT
	MyOutData.PaketData.SendSucsess := FALSE;
	//paket away...
	WasSendet := FALSE;
	requestToSend := FALSE; 
	done := TRUE;
	DUP := FALSE;
	MyOutData.PaketData.DUP := FALSE;
	TimeToResponse := TICKS.GetTick(xDummy:= TRUE) - LastSend;
	CountSend := CountSend + 1;
END_IF

SendTimeOutTime(IN:= requestToSend, PT:= MyConstants.SENDING_TIMEOUT);
SendTimeout := SendTimeOutTime.Q;

sendActive := requestToSend;</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>cc2d5fcf-b68d-4e57-b744-68b746e30a3b</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="MQTTState" pouType="functionBlock">
        <interface>
          <localVars>
            <variable name="State">
              <type>
                <pointer>
                  <baseType>
                    <BOOL />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="Topic">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="StateName">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="StateValueOn">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="StateValueOff">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="InitDone">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="Send">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="SendDone">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="RequestToSendOn">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="RequestToSendOff">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="publish">
              <type>
                <derived name="MQTTPublish" />
              </type>
            </variable>
            <variable name="PayloadTemplate">
              <type>
                <string length="255" />
              </type>
            </variable>
            <variable name="Payload">
              <type>
                <string length="255" />
              </type>
            </variable>
            <variable name="QoS">
              <type>
                <derived name="QoS" />
              </type>
            </variable>
            <variable name="RetainMqtt">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="RT">
              <type>
                <derived name="R_TRIG" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">SendBlock: BOOL;</xhtml>
              </documentation>
            </variable>
            <variable name="FT">
              <type>
                <derived name="F_TRIG" />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">//need to call publish here because of FB nums
publish(
	Topic:= Topic, 
	PayloadString:= ADR(Payload), 
	PublishAsString:= TRUE, 
	QoSIn:= QoS, 
	MRetain:= RetainMqtt, 
	send:= Send, 
	done=&gt; SendDone);

IF NOT InitDone THEN RETURN; END_IF
RT(CLK:= State^);
FT(CLK:= State^);

IF RT.Q THEN
	RequestToSendOn := TRUE;
END_IF

IF FT.Q THEN
	RequestToSendOff := TRUE;
END_IF

IF RequestToSendOn AND NOT send THEN
	//send on
	send:= TRUE;
	Payload := PayloadTemplate;
	CommonTypesAndFunctions.concat(s1:= ADR(Payload), s2:= StateValueOn);
	RequestToSendOn := FALSE;
END_IF

IF RequestToSendOff AND NOT send THEN
	//send on
	send:= TRUE;
	Payload := PayloadTemplate;
	CommonTypesAndFunctions.concat(s1:= ADR(Payload), s2:= StateValueOff);
	RequestToSendOff := FALSE;
END_IF

IF SendDone THEN
	Send := FALSE;
END_IF</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="Init" ObjectId="1e403734-4c33-4f63-a784-3b0e0ec24e6c">
              <interface>
                <inputVars>
                  <variable name="State">
                    <type>
                      <pointer>
                        <baseType>
                          <BOOL />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">pointer to state</xhtml>
                    </documentation>
                  </variable>
                  <variable name="Topic">
                    <type>
                      <pointer>
                        <baseType>
                          <string />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">topic name</xhtml>
                    </documentation>
                  </variable>
                  <variable name="StateName">
                    <type>
                      <pointer>
                        <baseType>
                          <string />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">valuve name, placed with ':' bevor value</xhtml>
                    </documentation>
                  </variable>
                  <variable name="StateValueOn">
                    <type>
                      <pointer>
                        <baseType>
                          <string />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">name of state</xhtml>
                    </documentation>
                  </variable>
                  <variable name="StateValueOff">
                    <type>
                      <pointer>
                        <baseType>
                          <string />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                  <variable name="MQTT_IN_OUT">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="MQTT_IN_OUT" />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">Pointer MQTTT exchange strucure</xhtml>
                    </documentation>
                  </variable>
                  <variable name="QoS">
                    <type>
                      <derived name="QoS" />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">QoS lewvel of publish</xhtml>
                    </documentation>
                  </variable>
                  <variable name="RetainMqtt">
                    <type>
                      <BOOL />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">message should be ratained?</xhtml>
                    </documentation>
                  </variable>
                </inputVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">publish.SetMqttInOut(MQTT_IN_OUT := MQTT_IN_OUT);
THIS^.State := State;
THIS^.Topic := Topic;
THIS^.StateName := StateName;
THIS^.StateValueOff := StateValueOff;
THIS^.StateValueOn := StateValueOn;
THIS^.PayloadTemplate := StateName^;
//don't ad ':' if no name is given
IF NOT THIS^.PayloadTemplate[0] = 0 THEN
	CommonTypesAndFunctions.concat(s1:= ADR(THIS^.PayloadTemplate), s2:= ADR(':'));
ELSE
	PayloadTemplate[0] := 0;
END_IF

InitDone := TRUE;
THIS^.RetainMqtt := RetainMqtt;
THIS^.QoS := QoS;
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>45dda641-95c7-4e58-b79e-a2cab7a6bc2c</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="MQTTSubscribe" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="Subscribe">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">set to true to subscribe, set to false to unsubscribe</xhtml>
              </documentation>
            </variable>
            <variable name="Topic">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">your topic string</xhtml>
              </documentation>
            </variable>
            <variable name="QoSSubscribe">
              <type>
                <derived name="QoS" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Topic:STRING(MyConstants.COM_STRING_SIZE);
QoS level</xhtml>
              </documentation>
            </variable>
            <variable name="ExpectingString">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">set to true is you want an string as output, if so you get the String on PayloadString, else
		you get binary data on payload</xhtml>
              </documentation>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="PayloadString">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">the Payload String</xhtml>
              </documentation>
            </variable>
            <variable name="Payload">
              <type>
                <pointer>
                  <baseType>
                    <BYTE />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">pointer to binary payload</xhtml>
              </documentation>
            </variable>
            <variable name="PayloadSize">
              <type>
                <UDINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">size of binary payload</xhtml>
              </documentation>
            </variable>
            <variable name="TopicOut">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">here you get the compleete recived topic string</xhtml>
              </documentation>
            </variable>
            <variable name="SendTimeout">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Timout of sending(subscribe paket) while connection io --&gt; to much load</xhtml>
              </documentation>
            </variable>
            <variable name="SubscribeFail">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">error if subscribtion on broker fails or if topic isn't vailid</xhtml>
              </documentation>
            </variable>
            <variable name="TopicValid">
              <type>
                <derived name="TOPIC_VALID" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">here you get your topic check</xhtml>
              </documentation>
            </variable>
            <variable name="Recived">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Data for my Topic recived, edge</xhtml>
              </documentation>
            </variable>
            <variable name="TopicOutSplit">
              <type>
                <pointer>
                  <baseType>
                    <derived name="SPLIT_TOPIC" />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Recived splitted topic so you can look at sub topics an so one...</xhtml>
              </documentation>
            </variable>
          </outputVars>
          <localVars>
            <variable name="SubscribeRising">
              <type>
                <derived name="R_TRIG" />
              </type>
            </variable>
            <variable name="SubscribeFalling">
              <type>
                <derived name="F_TRIG" />
              </type>
            </variable>
            <variable name="NeedSubscribe">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="NeedUnsubscribe">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="SubscribeDone">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="SubscribeWasSended">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="UnsubscribeWasSended">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="MyOutData">
              <type>
                <derived name="DATA_TO_BROKER" />
              </type>
            </variable>
            <variable name="TimeToResponse">
              <type>
                <derived name="CAA.TICK" />
              </type>
            </variable>
            <variable name="LastSend">
              <type>
                <derived name="CAA.TICK" />
              </type>
            </variable>
            <variable name="SendTimeOutTime">
              <type>
                <derived name="ton" />
              </type>
            </variable>
            <variable name="RecivedQoS">
              <type>
                <derived name="QoS" />
              </type>
            </variable>
            <variable name="SplitTopic">
              <type>
                <derived name="SplitTopic" />
              </type>
            </variable>
            <variable name="RecivedPublishs">
              <type>
                <ULINT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">recived publishs</xhtml>
              </documentation>
            </variable>
            <variable name="init">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="FALSE" />
              </initialValue>
            </variable>
            <variable name="iu">
              <type>
                <UINT />
              </type>
            </variable>
          </localVars>
          <addData>
            <data name="http://www.3s-software.com/plcopenxml/pouinheritance" handleUnknown="implementation">
              <Inheritance>
                <Extends>MQTTBase</Extends>
              </Inheritance>
            </data>
          </addData>
          <documentation>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">use this to subscribe to a topic, if the topic you want to subscribe isn't vailid you get an error on output SubscribeFail
 </xhtml>
          </documentation>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">SUPER^();
//if not config, then leave, do this after super so we calc correct FB numbers
IF NOT DbPointerIo THEN RETURN; END_IF;
GVL_MQTT.ProgNum := PROG_NUM.Subscribe;
SubscribeFalling(CLK:= Subscribe);
SubscribeRising(CLK:= Subscribe);

IF NOT init THEN
	COM_CONFIG := MQTT_IN_OUT^.COM_CONFIG;
	SplitTopic.LowInit(TopicsLevelInit:= COM_CONFIG.MaxTopicLevels, SplitElementSizeInit:= COM_CONFIG.MaxTopicElementSize, dynMemUsageInit:= ADR(MQTT_IN_OUT^.dynMemUsage));
	init:= TRUE;
END_IF

IF NOT MQTT_IN_OUT^.BROKER_CONNECTED AND SubscribeDone AND Subscribe THEN
	//reconnect after disconnect
	NeedSubscribe := TRUE;
	SubscribeDone := FALSE;
	SubscribeWasSended := FALSE;
	UnsubscribeWasSended := FALSE;
END_IF

IF SubscribeRising.Q THEN
	NeedSubscribe := TRUE;
END_IF


IF SubscribeFalling.Q THEN
	NeedUnsubscribe := TRUE;
END_IF

//RequestToken(request:= (NeedSubscribe AND NOT SubscribeWasSended) OR (NeedUnsubscribe AND NOT UnsubscribeWasSended));

IF NeedSubscribe AND NOT SubscribeWasSended AND MQTT_IN_OUT^.InFree(* AND CheckToken()*) AND MQTT_IN_OUT^.BROKER_CONNECTED THEN
 
	//GetSplitTopic(in:= Topic, Target:= ADR(SplitTopic), CountSplitTopicSizeExceeded:= ADR(SubscribeCountSplitTopicSizeExceeded));
	TopicValid := SplitTopic.NewTopic(in:= Topic, test:= TRUE, SizeOfString:= 0); //CheckTopicValid(Target:= ADR(SplitTopic)); 
	IF TopicValid = TOPIC_VALID.TOPIC_VALID THEN
		//try to subscribe
		SubscribeWasSended := TRUE;
		//send free
		MQTT_IN_OUT^.IN := ADR(MyOutData);
		MQTT_IN_OUT^.InFree := FALSE;
		MyOutData.PaketData.FbId := MQTT_IN_OUT^.FB_NO_AUTO;
		MyOutData.PaketData.MessageType := MESSAGETYPE.SUBSCRIBE;
		MyOutData.PaketData.MessageQoS := QoSSubscribe;
		MyOutData.PaketData.MqttTopic := Topic;
		MyOutData.PaketData.MqttTopicLength := CommonTypesAndFunctions.LEN(Topic);
		SubscribeFail := FALSE;
	ELSE
		NeedSubscribe := FALSE;
		SubscribeFail := TRUE;
	END_IF
	ReleaseToken();
END_IF

IF NeedUnsubscribe AND NOT UnsubscribeWasSended AND MQTT_IN_OUT^.InFree(* AND CheckToken() *)AND MQTT_IN_OUT^.BROKER_CONNECTED THEN
	//try to unsubscribe
	UnsubscribeWasSended := TRUE;
	//send free
	MQTT_IN_OUT^.IN := ADR(MyOutData);
	MQTT_IN_OUT^.InFree := FALSE;
	MyOutData.PaketData.FbId := MQTT_IN_OUT^.FB_NO_AUTO;
	MyOutData.PaketData.MessageType := MESSAGETYPE.UNSUBSCRIBE;
	MyOutData.PaketData.MqttTopic := Topic;
	MyOutData.PaketData.MqttTopicLength := CommonTypesAndFunctions.LEN(Topic);
	ReleaseToken();
END_IF

//place behinde send, so leav "Token" to rest....
//here for Subscribe
IF MyOutData.PaketData.SendSucsess AND MyOutData.PaketData.MessageType = MESSAGETYPE.SUBSCRIBE THEN //scusses set by HANDLE_MQTT
	MyOutData.PaketData.SendSucsess := FALSE;
	//paket away...
	SubscribeWasSended := FALSE;
	NeedSubscribe := FALSE; 
	SubscribeDone := TRUE;
	TimeToResponse := TICKS.GetTick(xDummy:= TRUE) - LastSend;
	RecivedQoS := MyOutData.PaketData.SubackQoS;
	IF RecivedQoS = QoS.Fail THEN
		SubscribeFail := TRUE;
	ELSE
		SubscribeFail := FALSE;	
	END_IF
	
END_IF

//here for Unubscribe
IF MyOutData.PaketData.SendSucsess AND MyOutData.PaketData.MessageType = MESSAGETYPE.UNSUBSCRIBE THEN //scusses set by HANDLE_MQTT
	MyOutData.PaketData.SendSucsess := FALSE;
	//paket away...
	UnsubscribeWasSended := FALSE;
	NeedUnsubscribe := FALSE; 
	SubscribeDone := FALSE;
	TimeToResponse := TICKS.GetTick(xDummy:= TRUE) - LastSend;
END_IF

//check if i get an paket //check if topic fits to me....
IF MQTT_IN_OUT^.OUT.DataRecived AND SubscribeDone THEN 
	//IF CheckTopicMatchToMe() = TOPIC_MATCH.TOPIC_MATCHES THEN
	IF SplitTopic.CheckTopicMatchToMe(with:= MQTT_IN_OUT^.OUT.Topics) = TOPIC_MATCH.TOPIC_MATCHES THEN
		Recived := TRUE;
		TopicOut := MQTT_IN_OUT^.OUT.MqttTopic;
		IF ExpectingString THEN
			MQTT_IN_OUT^.OUT.MqttPayload[MQTT_IN_OUT^.OUT.MqttPayloadSize] := 0;//set string limiter
			PayloadString := MQTT_IN_OUT^.OUT.MqttPayload;
		ELSE
			Payload := MQTT_IN_OUT^.OUT.MqttPayload;
			PayloadSize := 	MQTT_IN_OUT^.OUT.MqttPayloadSize;
		END_IF
		
		TopicOutSplit := ADR(MQTT_IN_OUT^.OUT.Topics);
		RecivedPublishs := RecivedPublishs + 1;
	END_IF
ELSE
	Recived := FALSE;	
END_IF
	


SendTimeOutTime(IN:= NeedSubscribe OR NeedUnsubscribe, PT:= MyConstants.SENDING_TIMEOUT);
SendTimeout := SendTimeOutTime.Q;
</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>dd71ef48-a746-409a-bd12-2cc36b1fc25e</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="MQTTValue" pouType="functionBlock">
        <interface>
          <localVars>
            <variable name="Topic">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="ValueName">
              <type>
                <pointer>
                  <baseType>
                    <string />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="ValuePointer">
              <type>
                <derived name="CommonTypesAndFunctions.ALL_TYPES_UNION_POINTER" />
              </type>
            </variable>
            <variable name="ValueType">
              <type>
                <derived name="CommonTypesAndFunctions.VAR_TYPES" />
              </type>
            </variable>
            <variable name="ValueDiff">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="Value">
              <type>
                <derived name="CommonTypesAndFunctions.ALL_TYPES_UNION" />
              </type>
            </variable>
            <variable name="InitDone">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="Send">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="SendDone">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="OldValue">
              <type>
                <derived name="CommonTypesAndFunctions.ALL_TYPES_UNION" />
              </type>
            </variable>
            <variable name="RequestToSend">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="publish">
              <type>
                <derived name="MQTTPublish" />
              </type>
            </variable>
            <variable name="PayloadTemplate">
              <type>
                <string length="255" />
              </type>
            </variable>
            <variable name="Payload">
              <type>
                <string length="255" />
              </type>
            </variable>
            <variable name="DecimalPlace">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="ValueString">
              <type>
                <string />
              </type>
            </variable>
            <variable name="QoS">
              <type>
                <derived name="QoS" />
              </type>
            </variable>
            <variable name="RetainMqtt">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="PowerForReal">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="MinTime">
              <type>
                <TIME />
              </type>
            </variable>
            <variable name="MinTimeTimer">
              <type>
                <derived name="ton" />
              </type>
            </variable>
            <variable name="SendBlock">
              <type>
                <BOOL />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">//need to call publish here because of FB nums
publish(
	Topic:= Topic, 
	PayloadString:= ADR(Payload), 
	PublishAsString:= TRUE, 
	QoSIn:= QoS, 
	MRetain:= RetainMqtt, 
	send:= Send, 
	done=&gt; SendDone);

IF NOT InitDone THEN RETURN; END_IF
MinTimeTimer(IN:= SendBlock, PT:= MinTime);
IF MinTimeTimer.Q THEN
	SendBlock := FALSE;
END_IF

Value := CommonTypesAndFunctions.GetValueFromPointer(PointerToValue:= ValuePointer, TypeOfValue:= ValueType);
IF NOT SendBlock THEN
	IF CommonTypesAndFunctions.CheckDeltaValue(Value:= Value,
			 TypeOfValue:= ValueType, DeltaVar:= ValueDiff, LastValue:= OldValue,Faktor:= PowerForReal)THEN
		RequestToSend := TRUE;
	END_IF
END_IF
		 
IF RequestToSend AND NOT Send AND NOT SendBlock THEN
	Payload := PayloadTemplate;
	ValueString := CommonTypesAndFunctions.GetValueString(VALUE:= Value, TypeOfValue:= ValueType, DecimalPlace:= DecimalPlace);
	CommonTypesAndFunctions.concat(s1:= ADR(Payload), s2:= ADR(ValueString));
	Send := TRUE;
	RequestToSend := FALSE;
END_IF

IF SendDone THEN
	Send := FALSE;
	SendBlock := TRUE;
END_IF</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="Init" ObjectId="7761ef91-55fb-474b-8fce-5f93c68f1f9d">
              <interface>
                <inputVars>
                  <variable name="Topic">
                    <type>
                      <pointer>
                        <baseType>
                          <string />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">topic name</xhtml>
                    </documentation>
                  </variable>
                  <variable name="ValueName">
                    <type>
                      <pointer>
                        <baseType>
                          <string />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">valuve name, placed with ':' bevor value</xhtml>
                    </documentation>
                  </variable>
                  <variable name="ValuePointer">
                    <type>
                      <derived name="CommonTypesAndFunctions.ALL_TYPES_UNION_POINTER" />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">pointer to value, can be every datatype</xhtml>
                    </documentation>
                  </variable>
                  <variable name="ValueType">
                    <type>
                      <derived name="CommonTypesAndFunctions.VAR_TYPES" />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">type of the var pointet by ValuePointer</xhtml>
                    </documentation>
                  </variable>
                  <variable name="ValueDiff">
                    <type>
                      <UINT />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">differenz wich the value have to change bovor it is beeing send. if floting point values it depends on decimals(differen :=1, decimal := 1 --&gt; 0.1 differenz )</xhtml>
                    </documentation>
                  </variable>
                  <variable name="MQTT_IN_OUT">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="MQTT_IN_OUT" />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">Pointer MQTTT exchange strucure</xhtml>
                    </documentation>
                  </variable>
                  <variable name="DecimalPlace">
                    <type>
                      <INT />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">decimal places behind comma on floting point values</xhtml>
                    </documentation>
                  </variable>
                  <variable name="QoS">
                    <type>
                      <derived name="QoS" />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">QoS lewvel of publish</xhtml>
                    </documentation>
                  </variable>
                  <variable name="RetainMqtt">
                    <type>
                      <BOOL />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">message should be ratained?</xhtml>
                    </documentation>
                  </variable>
                  <variable name="MinTime">
                    <type>
                      <TIME />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">min Time between publish</xhtml>
                    </documentation>
                  </variable>
                </inputVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">publish.SetMqttInOut(MQTT_IN_OUT := MQTT_IN_OUT);
THIS^.ValuePointer := ValuePointer;
IF ValueDiff = 0 THEN
	THIS^.ValueDiff := 1;
ELSE
	THIS^.ValueDiff := ValueDiff;	
END_IF

THIS^.Topic := Topic;
THIS^.ValueName := ValueName;
THIS^.ValueType := ValueType;
THIS^.PayloadTemplate := ValueName^;
//don't ad ':' if no name is given
IF NOT THIS^.PayloadTemplate[0] = 0 THEN
	CommonTypesAndFunctions.concat(s1:= ADR(THIS^.PayloadTemplate), s2:= ADR(':'));
END_IF
THIS^.DecimalPlace := DecimalPlace;
InitDone := TRUE;
THIS^.RetainMqtt := RetainMqtt;
THIS^.QoS := QoS;
IF THIS^.ValueType = CommonTypesAndFunctions.VAR_TYPES.LREAL_T OR 
	THIS^.ValueType = CommonTypesAndFunctions.VAR_TYPES.REAL_T THEN
	PowerForReal := TO_UINT(EXPT(10,DecimalPlace));
END_IF
THIS^.MinTime := MinTime;</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>7cbccac7-37d7-452a-91d9-21795ebc51d9</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="SplitTopic" pouType="functionBlock">
        <interface>
          <localVars>
            <variable name="SplitTopic">
              <type>
                <derived name="SPLIT_TOPIC" />
              </type>
            </variable>
            <variable name="InitFull">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="InitLow">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="SplitLength">
              <type>
                <pointer>
                  <baseType>
                    <UINT />
                  </baseType>
                </pointer>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">this is going to be a pointer to a array of uint to store the string length(and so memmory size) in the string array </xhtml>
              </documentation>
            </variable>
            <variable name="TopicsLevel">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="SplitElementSize">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="CountSizeExceeded">
              <type>
                <ULINT />
              </type>
            </variable>
            <variable name="TopicsIndexMax">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="dynMemUsage">
              <type>
                <pointer>
                  <baseType>
                    <UDINT />
                  </baseType>
                </pointer>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">{info 'TODO test of zeros in strings'}</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="FullInit" ObjectId="ceb1e346-4e57-4b78-8421-2c1d641d22cf">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="TopicsLevelInit">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                  <variable name="SplitElementSizeInit">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                  <variable name="dynMemUsageInit">
                    <type>
                      <pointer>
                        <baseType>
                          <UDINT />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="iu">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </localVars>
                <documentation>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">use FOR high change OF topic, needs more ram, saves TIME...
allocates all memory for the string arrays and strings
usefull for often changed topics like recive publish
</xhtml>
                </documentation>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">dynMemUsage := dynMemUsageInit;
destroy();

InitFull := TRUE;
InitLow := FALSE;

TopicsLevel := TopicsLevelInit;
SplitElementSize := SplitElementSizeInit + 1;//add 1 for trailing 0
IF TopicsLevel &gt; 0 THEN
	TopicsIndexMax := TopicsLevel - 1;
ELSE
	TopicsIndexMax := 0;
END_IF

{warning disable C0033}
//get memory for array of pointer to strings
SplitTopic.Topics := SysMem23.SysMemAlloc(dwSize:= TopicsLevel * SIZEOF(SplitTopic.Topics^));
dynMemUsage^ := dynMemUsage^ + TopicsLevel * SIZEOF(SplitTopic.Topics^);
FOR iu := 0 TO TopicsLevel - 1 DO
	//Get memory for strings
	SplitTopic.Topics[iu] := SysMem23.SysMemAlloc(dwSize:= SplitElementSize);	
	dynMemUsage^ := dynMemUsage^ + SplitElementSize;
END_FOR
{warning restore C0033}
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="LowInit" ObjectId="aee97ce3-b520-46d2-ba03-088505d4b950">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="TopicsLevelInit">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                  <variable name="SplitElementSizeInit">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                  <variable name="dynMemUsageInit">
                    <type>
                      <pointer>
                        <baseType>
                          <UDINT />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="iu">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </localVars>
                <documentation>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">use for low change of topic, saves mem, needs time
dynamic allocation of memory, usefull for static stopis like compare of subscription topic
</xhtml>
                </documentation>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">dynMemUsage := dynMemUsageInit;
destroy();
InitFull := FALSE;
InitLow := TRUE;

TopicsLevel := TopicsLevelInit;
SplitElementSize :=SplitElementSizeInit;
IF TopicsLevel &gt; 0 THEN
	TopicsIndexMax := TopicsLevel - 1;
ELSE
	TopicsIndexMax := 0;
END_IF
{warning disable C0033}
//get memory for array of pointer to string
SplitTopic.Topics := SysMem23.SysMemAlloc(dwSize:= TopicsLevel * SIZEOF(SplitTopic.Topics^));
dynMemUsage^ := dynMemUsage^ + TopicsLevel * SIZEOF(SplitTopic.Topics^);
//get memory for array of length of strings
SplitLength := SysMem23.SysMemAlloc(dwSize:= TopicsLevel * SIZEOF(SplitLength^));
dynMemUsage^ := dynMemUsage^ + TopicsLevel * SIZEOF(SplitLength^);
{warning restore C0033}
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="destroy" ObjectId="8cd22f1f-8fc7-489a-9664-9c5f3e657548">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <localVars>
                  <variable name="iu">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">GVL_MQTT.ProgNum := PROG_NUM.DESTROY_SPLIT_TOPIC;
IF InitFull THEN
{warning disable C0033}
	FOR iu := 0 TO TopicsLevel - 1 DO
		SysMem23.SysMemFree(dwAddress:= SplitTopic.Topics[iu], dwSize:= SplitElementSize);
		dynMemUsage^ := dynMemUsage^ - SplitElementSize;
	END_FOR
	SysMem23.SysMemFree(dwAddress:= SplitTopic.Topics, dwSize:= TopicsLevel * SIZEOF(SplitTopic.Topics^));
	dynMemUsage^ := dynMemUsage^ - (TopicsLevel * SIZEOF(SplitTopic.Topics^));
	InitFull := FALSE;
END_IF

IF InitLow THEN
	DestroyOldSplit();
	SysMem23.SysMemFree(dwAddress:= SplitTopic.Topics, dwSize:= TopicsLevel * SIZEOF(SplitTopic.Topics^));
	dynMemUsage^ := dynMemUsage^ - (TopicsLevel * SIZEOF(SplitTopic.Topics^));
	SysMem23.SysMemFree(dwAddress:= SplitLength, dwSize:= TopicsLevel * SIZEOF(SplitLength^));
	dynMemUsage^ := dynMemUsage^ - (TopicsLevel * SIZEOF(SplitLength^));
	InitLow:= FALSE;
END_IF
{warning restore C0033}</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="GetSplitTopic" ObjectId="4fc0a7a2-e23b-474c-83c1-ce1bc25ea8e6">
              <interface>
                <returnType>
                  <pointer>
                    <baseType>
                      <derived name="SPLIT_TOPIC" />
                    </baseType>
                  </pointer>
                </returnType>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">GetSplitTopic := ADR(SplitTopic);
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="FB_Exit" ObjectId="83390a32-5ae0-4d2a-9e1e-4f733a09628d">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="bInCopyCode">
                    <type>
                      <BOOL />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml"> TRUE: the exit method is called in order to leave the instance which will be copied afterwards (online change). </xhtml>
                    </documentation>
                  </variable>
                </inputVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">destroy();
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="NewTopic" ObjectId="5b35f434-7bb3-4f6b-8ddc-1205e223b0e8">
              <interface>
                <returnType>
                  <derived name="TOPIC_VALID" />
                </returnType>
                <inputVars>
                  <variable name="in">
                    <type>
                      <pointer>
                        <baseType>
                          <string />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">needs to be 0 terminated!</xhtml>
                    </documentation>
                  </variable>
                  <variable name="test">
                    <type>
                      <BOOL />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">check topic, use this for subscriptio, topics from broker should be ok...</xhtml>
                    </documentation>
                  </variable>
                  <variable name="SizeOfString">
                    <type>
                      <UINT />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">Size of String, if &gt; 0 then use this size and don't search for 0</xhtml>
                    </documentation>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="StartSub">
                    <type>
                      <DINT />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">in codesys for mid function first String Position is 1 !!!! devil!!!! don't use anymore, take memmove</xhtml>
                    </documentation>
                  </variable>
                  <variable name="i">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                  <variable name="SplitChar">
                    <type>
                      <BYTE />
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">SubCount:UINT;</xhtml>
                    </documentation>
                  </variable>
                  <variable name="pt">
                    <type>
                      <pointer>
                        <baseType>
                          <BYTE />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                  <variable name="UseSize">
                    <type>
                      <BOOL />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">IF NOT InitFull AND NOT InitLow THEN
	NewTopic := TOPIC_VALID.TOPIC_NOT_VALID;
	RETURN;
END_IF 
DestroyOldSplit();
SplitChar := CommonTypesAndFunctions.GetChar(in:= '/');
GVL_MQTT.ProgNum := PROG_NUM.GetSplitTopic;
IF SizeOfString &gt; 0 THEN
	UseSize := TRUE;
END_IF
pt := in;
WHILE (pt[i] &lt;&gt; 0 AND NOT UseSize) OR (UseSize AND SizeOfString &gt; 0) DO
	SizeOfString := SizeOfString - 1;
	IF pt[i] = SplitChar  THEN
		(*IF ((i - StartSub - 1) &gt; SplitElementSize AND InitFull)THEN
			
		END_IF*)
		IF NOT PushSplitLevel(str:= ADR(in^[StartSub]), len:= i - DINT_TO_UINT(StartSub)) THEN
			CountSizeExceeded := CountSizeExceeded + 1;
			//error pushing split topic
			DestroyOldSplit();
			NewTopic := TOPIC_VALID.TOPIC_NOT_VALID;
			RETURN;
		END_IF
		StartSub := i + 1;//Start Post at next after /
	END_IF
	i := i + 1;
END_WHILE
//get last Topic...
IF NOT (i = StartSub) THEN
	
	PushSplitLevel(str:= ADR(in^[StartSub]), len:= i - DINT_TO_UINT(StartSub));

END_IF
IF pt[i - 1] = SplitChar THEN
	//got one empty level at last
	PushSplitLevel(str:= in, len:= 0);//here str doesnt need to be a valid source
END_IF
IF test THEN
	NewTopic := CheckTopicValid();
	IF NewTopic = TOPIC_VALID.TOPIC_NOT_VALID THEN
		DestroyOldSplit();
	END_IF
ELSE
	NewTopic := TOPIC_VALID.TOPIC_NO_TEST;
END_IF</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="PushSplitLevel" ObjectId="2308047e-24eb-4016-a5c6-8ccd0f2d9c7f">
              <interface>
                <returnType>
                  <BOOL />
                </returnType>
                <inputVars>
                  <variable name="str">
                    <type>
                      <pointer>
                        <baseType>
                          <string />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                  <variable name="len">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="DynLength">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">//make sure to use no more memmory as allocated
IF (SplitTopic.ValidFields &gt;=  TopicsIndexMax) OR ((len + 1 &gt; SplitElementSize) AND InitFull) THEN
	PushSplitLevel := FALSE;
	RETURN;
ELSE
	PushSplitLevel := TRUE;
END_IF

IF InitFull THEN
	IF len &gt; 0 THEN
		{'info: TODO: check string length'}
		MEM.MemMove(pSource:= str, pDestination:= SplitTopic.Topics[SplitTopic.ValidFields], uiNumberOfBytes:= len);
	END_IF
	SplitTopic.Topics[SplitTopic.ValidFields]^[len] := 0;//string limiter
END_IF


IF InitLow THEN
	DynLength := len + 1;
	{warning disable C0033}
	SplitTopic.Topics[SplitTopic.ValidFields] := SysMem23.SysMemAlloc(dwSize:= DynLength);
	dynMemUsage^ := dynMemUsage^ + DynLength;
	{warning restore C0033}
	IF len &gt; 0 THEN
		MEM.MemMove(pSource:= str, pDestination:= SplitTopic.Topics[SplitTopic.ValidFields], uiNumberOfBytes:= len);
	END_IF
	SplitLength[SplitTopic.ValidFields] := DynLength;
	SplitTopic.Topics[SplitTopic.ValidFields]^[DynLength - 1] := 0;//string limiter
END_IF

SplitTopic.ValidFields := SplitTopic.ValidFields + 1;</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="DestroyOldSplit" ObjectId="9fa76813-2029-4e6a-971b-f556bb4f82e5">
              <interface>
                <localVars>
                  <variable name="di">
                    <type>
                      <DINT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">IF InitLow THEN
	FOR di := 0 TO SplitTopic.ValidFields - 1 DO
{warning disable C0033}
		SysMem23.SysMemFree(dwAddress:= SplitTopic.Topics[di], dwSize:= SplitLength[di]);
		dynMemUsage^ := dynMemUsage^ - SplitLength[di];
{warning restore C0033}		
	END_FOR
END_IF

SplitTopic.ValidFields := 0;</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="CheckTopicMatchToMe" ObjectId="40fb46a3-f73f-4707-8903-3d991face833">
              <interface>
                <returnType>
                  <derived name="TOPIC_MATCH" />
                </returnType>
                <inputVars>
                  <variable name="with">
                    <type>
                      <pointer>
                        <baseType>
                          <derived name="SPLIT_TOPIC" />
                        </baseType>
                      </pointer>
                    </type>
                    <documentation>
                      <xhtml xmlns="http://www.w3.org/1999/xhtml">topic to compare with, here the topic from broker</xhtml>
                    </documentation>
                  </variable>
                </inputVars>
                <localVars>
                  <variable name="i">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                  <variable name="pt">
                    <type>
                      <pointer>
                        <baseType>
                          <BYTE />
                        </baseType>
                      </pointer>
                    </type>
                  </variable>
                  <variable name="wildcard">
                    <type>
                      <BYTE />
                    </type>
                  </variable>
                </localVars>
                <documentation>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">Instance needs to be subscription topic</xhtml>
                </documentation>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">wildcard := CommonTypesAndFunctions.GetChar(in:= '#');
FOR i := 0 TO MIN(SplitTopic.ValidFields - 1, with^.ValidFields - 1) DO
	pt := SplitTopic.Topics[i]; 
	IF pt^ = wildcard THEN
		//from here its mine
		CheckTopicMatchToMe := TOPIC_MATCH.TOPIC_MATCHES;
		RETURN;
	END_IF
	IF NOT CheckTopicLevel(s1:= with^.Topics[i] , s2:= SplitTopic.Topics[i]) THEN
		CheckTopicMatchToMe := TOPIC_MATCH.TOPIC_DONT_MATCHES;
		RETURN;
	END_IF  
END_FOR
//if here and there are further topics then its note mine
IF SplitTopic.ValidFields = with^.ValidFields THEN
	CheckTopicMatchToMe := TOPIC_MATCH.TOPIC_MATCHES;
	RETURN;
END_IF
pt := ADR(SplitTopic.Topics[i]);
IF SplitTopic.ValidFields &gt; with^.ValidFields AND 
	pt^ = wildcard THEN
	//check last Subscription topic if '#'
	CheckTopicMatchToMe := TOPIC_MATCH.TOPIC_MATCHES;
ELSE
	CheckTopicMatchToMe := TOPIC_MATCH.TOPIC_DONT_MATCHES;
END_IF</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="CheckTopicValid" ObjectId="43d1c309-2ad2-4278-9176-896480b00081">
              <interface>
                <returnType>
                  <derived name="TOPIC_VALID" />
                </returnType>
                <localVars>
                  <variable name="i">
                    <type>
                      <UINT />
                    </type>
                  </variable>
                </localVars>
              </interface>
              <body>
                <ST>
                  <xhtml xmlns="http://www.w3.org/1999/xhtml">FOR i := 0 TO SplitTopic.ValidFields - 1 DO
	IF (CommonTypesAndFunctions.find(STR1:= SplitTopic.Topics[i], STR2:= ADR('#')) &gt;= 0) AND (CommonTypesAndFunctions.len(STR:= SplitTopic.Topics[i]) &gt; 1) THEN
		//error # within topic
		CheckTopicValid := TOPIC_VALID.TOPIC_NOT_VALID;
		RETURN;
		
	END_IF
	IF (CommonTypesAndFunctions.find(STR1:= SplitTopic.Topics[i], STR2:= ADR('+')) &gt;= 0) AND (CommonTypesAndFunctions.len(STR:= SplitTopic.Topics[i]) &gt; 1) THEN
		//error + within topic
		CheckTopicValid := TOPIC_VALID.TOPIC_NOT_VALID;
		RETURN;
	END_IF
		IF (CommonTypesAndFunctions.find(STR1:= SplitTopic.Topics[i], STR2:= ADR('#')) &gt;= 0) AND (i &lt;&gt; SplitTopic.ValidFields - 1) THEN
		//error # not at lowest topic
		CheckTopicValid := TOPIC_VALID.TOPIC_NOT_VALID;
		RETURN;
	END_IF
END_FOR
CheckTopicValid := TOPIC_VALID.TOPIC_VALID;
</xhtml>
                </ST>
              </body>
              <addData />
            </Method>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>42eb1e91-cc42-47d6-98e4-0b800a4d947f</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="PLC_PRG" pouType="program">
        <interface>
          <localVars>
            <variable name="MQTT">
              <type>
                <derived name="HANDLE_MQTT" />
              </type>
            </variable>
            <variable name="MQTT_INFO">
              <type>
                <derived name="MQTT_INFO" />
              </type>
            </variable>
            <variable name="MQTT_IN_OUT">
              <type>
                <derived name="MQTT_IN_OUT" />
              </type>
            </variable>
            <variable name="ERROR_C">
              <type>
                <DWORD />
              </type>
            </variable>
            <variable name="ERROR_T">
              <type>
                <BYTE />
              </type>
            </variable>
            <variable name="testPiublish">
              <type>
                <array>
                  <dimension lower="0" upper="100" />
                  <baseType>
                    <derived name="MQTTPublish" />
                  </baseType>
                </array>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">testPiublish: SD_MQTT.MQTTPublish;</xhtml>
              </documentation>
            </variable>
            <variable name="init">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="FALSE" />
              </initialValue>
            </variable>
            <variable name="sendTest">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="testtime">
              <type>
                <derived name="ton" />
              </type>
            </variable>
            <variable name="i">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="qos">
              <type>
                <derived name="QoS" />
              </type>
              <initialValue>
                <simpleValue value="2" />
              </initialValue>
            </variable>
            <variable name="sub1">
              <type>
                <derived name="MQTTSubscribe" />
              </type>
            </variable>
            <variable name="con">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="recived">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Testtopic:SD_MQTT.TestcaseCheckTopivValid;
TestSubscribe:SD_MQTT.TestSubscribe;</xhtml>
              </documentation>
            </variable>
            <variable name="CountSucsess">
              <type>
                <array>
                  <dimension lower="0" upper="100" />
                  <baseType>
                    <ULINT />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="MQTTretain">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="TRUE" />
              </initialValue>
            </variable>
            <variable name="enable">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="ReciveData">
              <type>
                <array>
                  <dimension lower="0" upper="100" />
                  <baseType>
                    <derived name="RECIVE_PAKET" />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="reciveIndex">
              <type>
                <INT />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">MQTT_IN_OUT.ClientID :='testCodesys';
//MQTT_IN_OUT.PORT := 1883;
//MQTT_IN_OUT.URL := 'test.mosquitto.org';
(*
testtime(IN:= NOT testtime.Q AND sendTest, PT:= T#100MS);
//testtime(IN:= NOT testtime.Q AND sendTest, PT:= T#10S);
IF NOT init THEN
	init := TRUE;
	testPiublish[0].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[1].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[2].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[3].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[4].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[5].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[6].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[7].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[8].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[9].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[10].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[11].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[12].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[13].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[14].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[15].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	sub1.SetMqttInOut(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
	//Testtopic();

END_IF

FOR i := 0 TO 20 DO
	CountSucsess[i] := testPiublish[i].CountSend;
END_FOR

//	TestSubscribe();
sub1(
	Subscribe:= con, 
	Topic:= 'test/#', 
	QoSSubscribe:= 2 ,
	Recived =&gt; recived
	 );
IF recived THEN
	i:=i;
	ReciveData[reciveIndex].MqttPayload := sub1.PayloadString^;
	ReciveData[reciveIndex].MqttTopic := sub1.TopicOut^;
	reciveIndex := reciveIndex + 1;
	IF reciveIndex &gt; 100 THEN
		reciveIndex := 0;
	END_IF
END_IF
testPiublish[0](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/1', 
	PayloadString:= 'test pi1', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q,
	PublishString := TRUE 
	);
	
testPiublish[1](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/2', 
	PayloadString:= 'test pi2', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q,
	PublishString := TRUE 
	);
testPiublish[2](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/3', 
	PayloadString:= 'test pi3', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q,
	PublishString := TRUE 
	);
testPiublish[3](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/4', 
	PayloadString:= 'test pi4', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishString := TRUE
	);
testPiublish[4](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/5', 
	PayloadString:= 'test pi5', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishString := TRUE
	);
testPiublish[5](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/6', 
	PayloadString:= 'test pi6', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishString := TRUE
	);
testPiublish[6](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/7', 
	PayloadString:= 'test pi7', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishString := TRUE
	);
testPiublish[7](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/8', 
	PayloadString:= 'test pi8', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishString := TRUE
	);
testPiublish[8](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/9', 
	PayloadString:= 'test pi9', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishString := TRUE
	);
testPiublish[9](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/10', 
	PayloadString:= 'test pi10', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishString := TRUE
	);
testPiublish[10](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/11', 
	PayloadString:= 'test pi11', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishString := TRUE
	);
testPiublish[11](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/12', 
	PayloadString:= 'test pi12', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishString := TRUE
	);
testPiublish[12](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/13', 
	PayloadString:= 'test pi13', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishString := TRUE
	);
testPiublish[13](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/14', 
	PayloadString:= 'test pi14', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishString := TRUE
	);
testPiublish[14](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/15', 
	PayloadString:= 'test pi15', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishString := TRUE
	);
testPiublish[15](
	Topic:= 'test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/16', 
	PayloadString:= 'test pi16', 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishString := TRUE
	);



(*
MQTT(
	MQTT_INFO:= MQTT_INFO, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= TRUE, 
	URL:= 'test.mosquitto.org:1883', 
	TIMEOUT:= T#5S, 
	ERROR_C=&gt; ERROR_C, 
	ERROR_T=&gt; ERROR_T);
	*)
	(*
	MQTT(
	MQTT_INFO:= MQTT_INFO, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= enable, 
	URL:= 'localhost:1883', 
	TIMEOUT:= T#5S, 
	ERROR_C=&gt; ERROR_C, 
	ERROR_T=&gt; ERROR_T);
	*)



MQTT(
	MQTT_INFO:= MQTT_INFO, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= TRUE, 
	URL:= 'windows-10-pro:1883', 
	TIMEOUT:= T#5S, 
	ERROR_C=&gt; ERROR_C, 
	ERROR_T=&gt; ERROR_T);
*)</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>889aed6b-4c51-400b-a3fa-ee165d5c3463</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="TestcaseCheckTopivValid" pouType="functionBlock">
        <interface>
          <localVars>
            <variable name="t1">
              <type>
                <derived name="SplitTopic" />
              </type>
            </variable>
            <variable name="s100">
              <type>
                <string length="101" />
              </type>
              <initialValue>
                <simpleValue value="'1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'" />
              </initialValue>
            </variable>
            <variable name="splus">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'+'" />
              </initialValue>
            </variable>
            <variable name="ssharp">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'#'" />
              </initialValue>
            </variable>
            <variable name="stest">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'test'" />
              </initialValue>
            </variable>
            <variable name="valids">
              <type>
                <array>
                  <dimension lower="0" upper="30" />
                  <baseType>
                    <string />
                  </baseType>
                </array>
              </type>
              <initialValue>
                <arrayValue>
                  <value>
                    <simpleValue value="'/+//sdf/test1'" />
                  </value>
                  <value>
                    <simpleValue value="'/sd//'" />
                  </value>
                  <value>
                    <simpleValue value="'test1/+/rest/#'" />
                  </value>
                  <value>
                    <simpleValue value="'test1/#'" />
                  </value>
                  <value>
                    <simpleValue value="'test1/topic2/+/Topic3/+/5636/ggesd'" />
                  </value>
                  <value>
                    <simpleValue value="'///'" />
                  </value>
                  <value>
                    <simpleValue value="'///+//sdf/test1//'" />
                  </value>
                  <value>
                    <simpleValue value="'//+//sdf/test1/'" />
                  </value>
                  <value>
                    <simpleValue value="'#'" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                </arrayValue>
              </initialValue>
            </variable>
            <variable name="falses">
              <type>
                <array>
                  <dimension lower="0" upper="30" />
                  <baseType>
                    <string />
                  </baseType>
                </array>
              </type>
              <initialValue>
                <arrayValue>
                  <value>
                    <simpleValue value="'test1/topic2/+/Topic3#/'" />
                  </value>
                  <value>
                    <simpleValue value="'test1/#/topic2/+/Topic3/#456'" />
                  </value>
                  <value>
                    <simpleValue value="'test1+'" />
                  </value>
                  <value>
                    <simpleValue value="'test1/#/topic2/+/Topic3/+/5636/ggesd'" />
                  </value>
                  <value>
                    <simpleValue value="'test1#'" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                  <value>
                    <simpleValue value="''" />
                  </value>
                </arrayValue>
              </initialValue>
            </variable>
            <variable name="s1">
              <type>
                <string length="64000" />
              </type>
            </variable>
            <variable name="valid">
              <type>
                <derived name="TOPIC_VALID" />
              </type>
            </variable>
            <variable name="pts">
              <type>
                <array>
                  <dimension lower="0" upper="20" />
                  <baseType>
                    <pointer>
                      <baseType>
                        <string />
                      </baseType>
                    </pointer>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="sp">
              <type>
                <pointer>
                  <baseType>
                    <derived name="SPLIT_TOPIC" />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="COM_CONFIG">
              <type>
                <derived name="COM_CONFIG" />
              </type>
            </variable>
            <variable name="dynMemUsage">
              <type>
                <UDINT />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">	(*GetSplitTopic(in:= 'test1/topic2/+/Topic3#/', Target:= ADR(dis1), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
	
	GetSplitTopic(in:= 'test1/#/topic2/+/Topic3/#456', Target:= ADR(dis2), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
	GetSplitTopic(in:= 'test1/+/rest/#', Target:= ADR(dis3), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
	GetSplitTopic(in:= 'test1/#', Target:= ADR(dis4), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
	GetSplitTopic(in:= 'test1/topic2/+/Topic3/+/5636/ggesd', Target:= ADR(dis5), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
	GetSplitTopic(in:= 'test1/#/topic2/+/Topic3/+/5636/ggesd', Target:= ADR(dis6), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
	GetSplitTopic(in:= 'test1#', Target:= ADR(dis7), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
	GetSplitTopic(in:= 'test1+', Target:= ADR(dis8), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
	GetSplitTopic(in:= '/+//sdf/test1', Target:= ADR(dis9), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
	GetSplitTopic(in:= '//+//sdf/test1/', Target:= ADR(dis10), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
	GetSplitTopic(in:= '///+//sdf/test1//', Target:= ADR(dis11), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
	GetSplitTopic(in:= '///', Target:= ADR(dis12), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
	GetSplitTopic(in:= '/sd//', Target:= ADR(dis13), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
	Valid1:=CheckTopicValid(Target:= ADR(dis1));
	Valid2:=CheckTopicValid(Target:= ADR(dis2));
	Valid3:=CheckTopicValid(Target:= ADR(dis3));
	Valid4:=CheckTopicValid(Target:= ADR(dis4));
	Valid5:=CheckTopicValid(Target:= ADR(dis5));
	Valid6:=CheckTopicValid(Target:= ADR(dis6));
	Valid7:=CheckTopicValid(Target:= ADR(dis7));
	Valid8:=CheckTopicValid(Target:= ADR(dis8));
	Valid9:=CheckTopicValid(Target:= ADR(dis9));
	*)
	
	t1.LowInit(SplitElementSizeInit:=400, TopicsLevelInit:= 40, dynMemUsageInit:= ADR(dynMemUsage));
	valid := t1.NewTopic(in := ADR(valids[0]), test:= TRUE, SizeOfString:= 0);
	sp := t1.GetSplitTopic();
	pts[0] := sp^.Topics[0];
	pts[1] := sp^.Topics[1];
	pts[2] := sp^.Topics[2];
	pts[3] := sp^.Topics[3];
	pts[4] := sp^.Topics[4];
	pts[5] := sp^.Topics[5];
	pts[6] := sp^.Topics[6];
	pts[7] := sp^.Topics[7];
	pts[8] := sp^.Topics[8];
	valid := t1.NewTopic(in := ADR(valids[1]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(valids[2]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(valids[3]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(valids[4]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(valids[5]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(valids[6]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(valids[7]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(valids[8]), test:= TRUE, SizeOfString:= 0);
	
	valid := t1.NewTopic(in := ADR(falses[0]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(falses[1]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(falses[2]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(falses[3]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(falses[4]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(falses[5]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(falses[6]), test:= TRUE, SizeOfString:= 0);
	valid := t1.NewTopic(in := ADR(falses[7]), test:= TRUE, SizeOfString:= 0);
	
	
	//now bulid some realy big topics and thest them....
	s1 :='';
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(s100));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(splus));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(s100));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(s100));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(ssharp));
	//valid
	valid := t1.NewTopic(in := ADR(s1), test:= TRUE, SizeOfString:= 0);
	s1 :='';
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(s100));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(splus));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(s100));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(s100));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(ssharp));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	//not valid # not at last pos
	valid := t1.NewTopic(in := ADR(s1), test:= TRUE, SizeOfString:= 0);
	s1 :='';
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(s100));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(splus));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(s100));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(splus));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(s100));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(ssharp));
	
	//not valid + within topic
	valid := t1.NewTopic(in := ADR(s1), test:= TRUE, SizeOfString:= 0);
	
	s1 :='';
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(s100));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(splus));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(s100));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(ssharp));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(s100));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(ssharp));
	
	//not valid # within topic
	valid := t1.NewTopic(in := ADR(s1), test:= TRUE, SizeOfString:= 0);</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>632e8e92-ad6c-45dd-90a7-c985f011dd34</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="testHighRecive" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="topics">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="TEST_TOPICS" />
              </initialValue>
            </variable>
            <variable name="broker">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'test.mosquitto.org:1883'" />
              </initialValue>
            </variable>
            <variable name="addTopic">
              <type>
                <string length="200" />
              </type>
            </variable>
          </inputVars>
          <localVars>
            <variable name="MQTT">
              <type>
                <derived name="HANDLE_MQTT" />
              </type>
            </variable>
            <variable name="MQTT_INFO">
              <type>
                <derived name="MQTT_INFO" />
              </type>
            </variable>
            <variable name="pub">
              <type>
                <derived name="MQTTPublish" />
              </type>
            </variable>
            <variable name="subs">
              <type>
                <derived name="MQTTSubscribe" />
              </type>
            </variable>
            <variable name="MQTT_IN_OUT">
              <type>
                <derived name="MQTT_IN_OUT" />
              </type>
            </variable>
            <variable name="tNewRun">
              <type>
                <derived name="TON" />
              </type>
            </variable>
            <variable name="init">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="i">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="testTopics">
              <type>
                <array>
                  <dimension lower="0" upper="TOPICS_MAX" />
                  <baseType>
                    <string length="255" />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="testPayload">
              <type>
                <array>
                  <dimension lower="0" upper="TOPICS_MAX" />
                  <baseType>
                    <string />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="testPayloadRecive">
              <type>
                <array>
                  <dimension lower="0" upper="TOPICS_MAX" />
                  <baseType>
                    <string />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="tmpString">
              <type>
                <string />
              </type>
            </variable>
            <variable name="step">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="topic">
              <type>
                <string length="255" />
              </type>
            </variable>
            <variable name="payload">
              <type>
                <string length="255" />
              </type>
            </variable>
            <variable name="sendPublish">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="subscribe">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="countPublish">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="noData">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="nextRun">
              <type>
                <BOOL />
              </type>
            </variable>
          </localVars>
          <localVars constant="true">
            <variable name="TEST_TOPICS">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="200" />
              </initialValue>
            </variable>
            <variable name="TOPICS_MAX">
              <type>
                <UINT />
              </type>
              <initialValue>
                <simpleValue value="1000" />
              </initialValue>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">IF NOT init THEN
	init := TRUE;
	pub.SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	subs.SetMqttInOut(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
	//Testtopic();
	FOR i := 0 TO topics - 1 DO
		tmpString := UINT_TO_STRING(i);
		testTopics[i] := 'RetainTopicSD/Topic:';
		CommonTypesAndFunctions.concat(s1:= ADR(testTopics[i]), s2:= ADR(addTopic));
		CommonTypesAndFunctions.concat(s1:= ADR(testTopics[i]), s2:= ADR(tmpString));
		CommonTypesAndFunctions.concat(s1:= ADR(testTopics[i]), s2:= ADR('/'));
		testPayload[i] := tmpString;
	END_FOR
END_IF
IF topics &gt;= TOPICS_MAX THEN
	topics := TOPICS_MAX;
END_IF
pub(
	Topic:= ADR(topic), 
	PayloadString:= ADR(payload), 
	PublishAsString:= TRUE, 
	QoSIn:= QoS.ExactlyOnce, 
	MRetain:= TRUE, 
	send:= sendPublish);
subs(
	Subscribe:= subscribe, 
	Topic:= ADR('RetainTopicSD/#'), 
	QoSSubscribe:= QoS.ExactlyOnce, 
	ExpectingString:= TRUE);
	
IF subs.Recived THEN
	FOR i := 0 TO topics - 1 DO
			IF testTopics[i] = subs.TopicOut^ THEN
				testPayloadRecive[i] := subs.PayloadString^;
			END_IF
	END_FOR
END_IF
MQTT(
	MQTT_INFO:= MQTT_INFO, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= TRUE, 
	URL:= broker, 
	TIMEOUT:= T#5S, 
	TLS:= FALSE);
IF NOT MQTT_INFO.MQTT_CONNECTED THEN
	step := 0;
END_IF
	
CASE step OF
	0: 	step := 1;
		countPublish := 0;
		FOR i := 0 TO topics - 1 DO
			testPayloadRecive[i] := '';
		END_FOR
	1: IF MQTT_INFO.MQTT_CONNECTED THEN
			step:= 10;
			countPublish := 0;
		END_IF
	10: //publish all data
		topic := testTopics[countPublish];
		payload := testPayload[countPublish];
		sendPublish := TRUE;
		countPublish := countPublish + 1;
		step := 20;
	20: IF pub.done THEN
		
			sendPublish := FALSE;
			IF countPublish &gt; topics - 1 THEN
				//start subscription
				step:= 30;
			ELSE
				step:= 10;
			END_IF
		END_IF
	30: subscribe := TRUE;
		step := 40;
		
	40: // wait to recive all topics
		noData := FALSE;
		FOR i := 0 TO topics - 1 DO
			IF testPayloadRecive[i] &lt;&gt; testPayload[i] THEN
				noData := TRUE;
			END_IF
		END_FOR
		IF NOT noData THEN
			step := 50; 
		END_IF 
		//unsubscripe
	50: subscribe := FALSE;
		step := 52;
		countPublish := 0;
		//cleanup recive buffer
		FOR i := 0 TO topics - 1 DO
			testPayloadRecive[i] :='';
		END_FOR
	52: //discharge retain messages from broker
		topic := testTopics[countPublish];
		payload := '';
		sendPublish := TRUE;
		countPublish := countPublish + 1;
		step := 54;
	54: IF pub.done THEN
		
			sendPublish := FALSE;
			IF countPublish &gt; topics - 1 THEN
				//start wait
				step:= 60;
			ELSE
				step:= 52;
			END_IF
		END_IF
	
	60:
		IF nextRun OR tNewRun.Q THEN 
			nextRun := FALSE;
			step := 0;
		END_IF
END_CASE

tNewRun(in := step = 60,PT:= T#1M);</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>2c7b7c99-a3d9-49b0-b749-8e7ba380eebe</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="TestMqtt" pouType="functionBlock">
        <interface>
          <localVars>
            <variable name="MQTT">
              <type>
                <derived name="HANDLE_MQTT" />
              </type>
            </variable>
            <variable name="MQTT_INFO">
              <type>
                <derived name="MQTT_INFO" />
              </type>
            </variable>
            <variable name="MQTT_IN_OUT">
              <type>
                <derived name="MQTT_IN_OUT" />
              </type>
            </variable>
            <variable name="ERROR_C">
              <type>
                <DWORD />
              </type>
            </variable>
            <variable name="ERROR_T">
              <type>
                <BYTE />
              </type>
            </variable>
            <variable name="testPiublish">
              <type>
                <array>
                  <dimension lower="0" upper="100" />
                  <baseType>
                    <derived name="MQTTPublish" />
                  </baseType>
                </array>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">testPiublish: SD_MQTT.MQTTPublish;</xhtml>
              </documentation>
            </variable>
            <variable name="init">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="FALSE" />
              </initialValue>
            </variable>
            <variable name="sendTest">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="testBigPublish">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="testBigPayload">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="testTimeBigPublish">
              <type>
                <derived name="ton" />
              </type>
            </variable>
            <variable name="testTimeBigPayload">
              <type>
                <derived name="ton" />
              </type>
            </variable>
            <variable name="testtime">
              <type>
                <derived name="ton" />
              </type>
            </variable>
            <variable name="i">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="qos">
              <type>
                <derived name="QoS" />
              </type>
              <initialValue>
                <simpleValue value="2" />
              </initialValue>
            </variable>
            <variable name="sub1">
              <type>
                <derived name="MQTTSubscribe" />
              </type>
            </variable>
            <variable name="sub2">
              <type>
                <derived name="MQTTSubscribe" />
              </type>
            </variable>
            <variable name="sub3">
              <type>
                <derived name="MQTTSubscribe" />
              </type>
            </variable>
            <variable name="con">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="TestLongSubscribe">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="recived1">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Testtopic:SD_MQTT.TestcaseCheckTopivValid;
TestSubscribe:SD_MQTT.TestSubscribe;</xhtml>
              </documentation>
            </variable>
            <variable name="recived2">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="recived3">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="longRecived">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="CountSucsess">
              <type>
                <array>
                  <dimension lower="0" upper="100" />
                  <baseType>
                    <ULINT />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="MQTTretain">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="TRUE" />
              </initialValue>
            </variable>
            <variable name="enable">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="ReciveData">
              <type>
                <array>
                  <dimension lower="0" upper="100" />
                  <baseType>
                    <derived name="RECIVE_PAKET" />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="reciveIndex">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="TestLen">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="SubscribeForBigPaket">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="t1">
              <type>
                <derived name="SplitTopic" />
              </type>
            </variable>
            <variable name="s100">
              <type>
                <string length="101" />
              </type>
              <initialValue>
                <simpleValue value="'1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'" />
              </initialValue>
            </variable>
            <variable name="sa">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'abcdefghijklmnopqrstuvwxyz'" />
              </initialValue>
            </variable>
            <variable name="sb">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'" />
              </initialValue>
            </variable>
            <variable name="sc">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'0123456789'" />
              </initialValue>
            </variable>
            <variable name="sd">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'9876543210'" />
              </initialValue>
            </variable>
            <variable name="splus">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'+'" />
              </initialValue>
            </variable>
            <variable name="ssharp">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'#'" />
              </initialValue>
            </variable>
            <variable name="stest">
              <type>
                <string />
              </type>
              <initialValue>
                <simpleValue value="'test'" />
              </initialValue>
            </variable>
            <variable name="s1">
              <type>
                <string length="64000" />
              </type>
            </variable>
            <variable name="s2">
              <type>
                <string length="64000" />
              </type>
            </variable>
            <variable name="b1">
              <type>
                <array>
                  <dimension lower="0" upper="(bSize + 2)" />
                  <baseType>
                    <BYTE />
                  </baseType>
                </array>
              </type>
            </variable>
          </localVars>
          <localVars constant="true">
            <variable name="bSize">
              <type>
                <UDINT />
              </type>
              <initialValue>
                <simpleValue value="((1024 * 1024) * 30)" />
              </initialValue>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">MQTT_IN_OUT.ClientID :='testCodesys';
MQTT_IN_OUT.COM_CONFIG.MaxPayloadSize :=50000;
MQTT_IN_OUT.COM_CONFIG.MaxTopicLevels := 200;
//MQTT_IN_OUT.PORT := 1883;
//MQTT_IN_OUT.URL := 'test.mosquitto.org';


{info 'TODO make some nice test cases'}




//testtime(IN:= , PT:= );
testtime(IN:= NOT testtime.Q AND sendTest, PT:= T#50MS);
testTimeBigPublish(IN:= NOT testTimeBigPublish.Q AND testBigPublish, PT:= T#100MS);
testTimeBigPayload(IN:= NOT testTimeBigPayload.Q AND testBigPayload, PT:= T#100MS);
//testtime(IN:= NOT testtime.Q AND sendTest, PT:= T#10S);
IF NOT init THEN
	init := TRUE;
	testPiublish[0].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[1].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[2].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[3].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[4].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[5].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[6].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[7].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[8].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[9].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[10].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[11].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[12].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[13].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[14].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[15].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[16].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[17].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	sub1.SetMqttInOut(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
	sub2.SetMqttInOut(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
	sub3.SetMqttInOut(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
	//Testtopic();
	FOR i := 0 TO 90 DO
		CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(sa));
		CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
		CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR(sb));
		CommonTypesAndFunctions.concat(s1:= ADR(s1), s2:= ADR('/'));
	END_FOR
		FOR i := 0 TO 10 DO
		CommonTypesAndFunctions.concat(s1:= ADR(s2), s2:= ADR(sc));
		CommonTypesAndFunctions.concat(s1:= ADR(s2), s2:= ADR('/'));
		CommonTypesAndFunctions.concat(s1:= ADR(s2), s2:= ADR(sd));
		CommonTypesAndFunctions.concat(s1:= ADR(s2), s2:= ADR('/'));
	END_FOR
	FOR i := 0 TO bSize DO
		b1[i] := UDINT_TO_BYTE(i);
	END_FOR
END_IF

FOR i := 0 TO 20 DO
	CountSucsess[i] := testPiublish[i].CountSend;
END_FOR

TestLen := CommonTypesAndFunctions.len(str:= ADR(''));
TestLen := CommonTypesAndFunctions.len(str:= ADR('a'));
TestLen := CommonTypesAndFunctions.len(str:= ADR('aa'));

//	TestSubscribe();
sub1(
	Subscribe:= con, 
	Topic:= ADR(s2), 
	QoSSubscribe:= 2,
	Recived =&gt; longRecived,
	ExpectingString := TRUE
	 );
sub2(
	Subscribe:= TestLongSubscribe, 
	Topic:= ADR(s1), 
	QoSSubscribe:= 2 ,
	Recived =&gt; recived1,
	ExpectingString := TRUE
	 );
sub3(
	Subscribe:= SubscribeForBigPaket, 
	Topic:= ADR('#'), 
	QoSSubscribe:= 2 ,
	Recived =&gt; recived2,
	ExpectingString := FALSE
	 );
IF recived1 THEN
	i:=i;
	ReciveData[reciveIndex].MqttPayload := sub1.PayloadString^;
	ReciveData[reciveIndex].MqttTopic := sub1.TopicOut^;
	reciveIndex := reciveIndex + 1;
	IF reciveIndex &gt; 100 THEN
		reciveIndex := 0;
	END_IF
END_IF
testPiublish[17](
	Topic:= ADR(s1), 
	Payload:= ADR(b1), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testTimeBigPayload.Q,
	PayloadLength :=  3654,
	PublishAsString := FALSE
	);
testPiublish[16](
	Topic:= ADR(s1), 
	PayloadString:= ADR(s2), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testTimeBigPublish.Q, 
	PublishAsString := TRUE
	);
testPiublish[0](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/1'), 
	PayloadString:= ADR('test pi1'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q,
	PublishAsString := TRUE 
	);
	
testPiublish[1](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/2'), 
	PayloadString:= ADR('test pi2'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q,
	PublishAsString := TRUE 
	);
testPiublish[2](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/3'), 
	PayloadString:= ADR('test pi3'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q,
	PublishAsString := TRUE 
	);
testPiublish[3](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/4'), 
	PayloadString:= ADR('test pi4'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[4](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/5'), 
	PayloadString:= ADR('test pi5'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[5](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/6'), 
	PayloadString:= ADR('test pi6'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[6](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/7'), 
	PayloadString:= ADR('test pi7'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[7](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/8'), 
	PayloadString:= ADR('test pi8'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[8](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/9'), 
	PayloadString:= ADR('test pi9'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[9](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/10'), 
	PayloadString:= ADR('test pi10'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[10](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/11'), 
	PayloadString:= ADR('test pi11'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[11](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/12'), 
	PayloadString:= ADR('test pi12'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[12](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/13'), 
	PayloadString:= ADR('test pi13'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[13](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/14'), 
	PayloadString:= ADR('test pi14'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[14](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/15'), 
	PayloadString:= ADR('test pi15'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[15](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/16'), 
	PayloadString:= ADR('test pi16'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);



(*
MQTT(
	MQTT_INFO:= MQTT_INFO, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= TRUE, 
	URL:= 'test.mosquitto.org:1883', 
	TIMEOUT:= T#5S, 
	ERROR_C=&gt; ERROR_C, 
	ERROR_T=&gt; ERROR_T);
	*)
	(*
	MQTT(
	MQTT_INFO:= MQTT_INFO, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= enable, 
	URL:= 'localhost:1883', 
	TIMEOUT:= T#5S, 
	ERROR_C=&gt; ERROR_C, 
	ERROR_T=&gt; ERROR_T);
	*)



MQTT(
	MQTT_INFO:= MQTT_INFO, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= enable, 
	URL:= 'windows-10-pro:1883', 
	TIMEOUT:= T#5S, 
	ERROR_C=&gt; ERROR_C, 
	ERROR_T=&gt; ERROR_T);
</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>04fc90f3-c020-40ea-9831-93a03c452235</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="TestMqttTLS" pouType="functionBlock">
        <interface>
          <localVars>
            <variable name="MQTT">
              <type>
                <derived name="HANDLE_MQTT" />
              </type>
            </variable>
            <variable name="MQTT_INFO">
              <type>
                <derived name="MQTT_INFO" />
              </type>
            </variable>
            <variable name="MQTT_IN_OUT">
              <type>
                <derived name="MQTT_IN_OUT" />
              </type>
            </variable>
            <variable name="ERROR_C">
              <type>
                <DWORD />
              </type>
            </variable>
            <variable name="ERROR_T">
              <type>
                <BYTE />
              </type>
            </variable>
            <variable name="testPiublish">
              <type>
                <array>
                  <dimension lower="0" upper="100" />
                  <baseType>
                    <derived name="MQTTPublish" />
                  </baseType>
                </array>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">testPiublish: SD_MQTT.MQTTPublish;</xhtml>
              </documentation>
            </variable>
            <variable name="init">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="FALSE" />
              </initialValue>
            </variable>
            <variable name="sendTest">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="testtime">
              <type>
                <derived name="ton" />
              </type>
            </variable>
            <variable name="i">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="qos">
              <type>
                <derived name="QoS" />
              </type>
              <initialValue>
                <simpleValue value="2" />
              </initialValue>
            </variable>
            <variable name="sub1">
              <type>
                <derived name="MQTTSubscribe" />
              </type>
            </variable>
            <variable name="sub2">
              <type>
                <derived name="MQTTSubscribe" />
              </type>
            </variable>
            <variable name="con">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="recived">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Testtopic:SD_MQTT.TestcaseCheckTopivValid;
TestSubscribe:SD_MQTT.TestSubscribe;</xhtml>
              </documentation>
            </variable>
            <variable name="CountSucsess">
              <type>
                <array>
                  <dimension lower="0" upper="100" />
                  <baseType>
                    <ULINT />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="MQTTretain">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="TRUE" />
              </initialValue>
            </variable>
            <variable name="enable">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="ReciveData">
              <type>
                <array>
                  <dimension lower="0" upper="100" />
                  <baseType>
                    <derived name="RECIVE_PAKET" />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="reciveIndex">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="testTls">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="TRUE" />
              </initialValue>
            </variable>
            <variable name="TLS_CONFIG">
              <type>
                <derived name="CommonTypesAndFunctions.TLS_CONFIG" />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">MQTT_IN_OUT.ClientID :='testCodesys';
//MQTT_IN_OUT.PORT := 1883;
//MQTT_IN_OUT.URL := 'test.mosquitto.org';

testtime(IN:= NOT testtime.Q AND sendTest, PT:= T#100MS);
//testtime(IN:= NOT testtime.Q AND sendTest, PT:= T#10S);
IF NOT init THEN
	init := TRUE;
	testPiublish[0].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[1].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[2].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[3].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[4].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[5].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[6].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[7].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[8].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[9].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[10].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[11].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[12].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[13].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[14].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	testPiublish[15].SetMqttInOut(MQTT_IN_OUT := ADR(MQTT_IN_OUT));
	sub1.SetMqttInOut(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
	sub2.SetMqttInOut(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
	//Testtopic();
	
	MQTT_IN_OUT.TLS_CONFIG := ADR(TLS_CONFIG);

END_IF

FOR i := 0 TO 20 DO
	CountSucsess[i] := testPiublish[i].CountSend;
END_FOR

//	TestSubscribe();
sub1(
	Subscribe:= con, 
	Topic:= ADR('test/#'), 
	QoSSubscribe:= 2 ,
	Recived =&gt; recived,
	ExpectingString := TRUE
	 );
	 
sub2(
	Subscribe:= con, 
	Topic:= ADR('#'), 
	QoSSubscribe:= 2 ,
	Recived =&gt; recived,
	ExpectingString := TRUE
	 );
IF recived THEN
	i:=i;
	ReciveData[reciveIndex].MqttPayload := sub1.PayloadString^;
	ReciveData[reciveIndex].MqttTopic := sub1.TopicOut^;
	reciveIndex := reciveIndex + 1;
	IF reciveIndex &gt; 100 THEN
		reciveIndex := 0;
	END_IF
END_IF
testPiublish[0](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/1'), 
	PayloadString:= ADR('test pi1'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q,
	PublishAsString := TRUE 
	);
	
testPiublish[1](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/2'), 
	PayloadString:= ADR('test pi2'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q,
	PublishAsString := TRUE 
	);
testPiublish[2](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/3'), 
	PayloadString:= ADR('test pi3'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q,
	PublishAsString := TRUE 
	);
testPiublish[3](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/4'), 
	PayloadString:= ADR('test pi4'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[4](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/5'), 
	PayloadString:= ADR('test pi5'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[5](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/6'), 
	PayloadString:= ADR('test pi6'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[6](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/7'), 
	PayloadString:= ADR('test pi7'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[7](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/8'), 
	PayloadString:= ADR('test pi8'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[8](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/9'), 
	PayloadString:= ADR('test pi9'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[9](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/10'), 
	PayloadString:= ADR('test pi10'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[10](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/11'), 
	PayloadString:= ADR('test pi11'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[11](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/12'), 
	PayloadString:= ADR('test pi12'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[12](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/13'), 
	PayloadString:= ADR('test pi13'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[13](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/14'), 
	PayloadString:= ADR('test pi14'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[14](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/15'), 
	PayloadString:= ADR('test pi15'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);
testPiublish[15](
	Topic:= ADR('test/topic veryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy big topic/16'), 
	PayloadString:= ADR('test pi16'), 
	QoSIn:= qos, 
	MRetain:= MQTTretain, 
	send := testtime.Q, 
	PublishAsString := TRUE
	);




(*
MQTT(
	MQTT_INFO:= MQTT_INFO, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= TRUE, 
	URL:= 'test.mosquitto.org:1883', 
	TIMEOUT:= T#5S, 
	ERROR_C=&gt; ERROR_C, 
	ERROR_T=&gt; ERROR_T);
	*)
	(*
	MQTT(
	MQTT_INFO:= MQTT_INFO, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= enable, 
	URL:= 'localhost:1883', 
	TIMEOUT:= T#5S, 
	ERROR_C=&gt; ERROR_C, 
	ERROR_T=&gt; ERROR_T);
	*)


IF testtls THEN
	
(*
MQTT(
	MQTT_INFO:= MQTT_INFO, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= enable, 
	URL:= 'windows-10-pro:8883', //8883 encryptet, 1883 unencryptet
	TIMEOUT:= T#5S, 
	TLS := TRUE,
	ERROR_C=&gt; ERROR_C, 
	ERROR_T=&gt; ERROR_T);
	*)
	MQTT(
	MQTT_INFO:= MQTT_INFO, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= enable, 
	URL:= 'test.mosquitto.org:8883', //8883 encryptet, 1883 unencryptet
	TIMEOUT:= T#5S, 
	TLS := TRUE,
	ERROR_C=&gt; ERROR_C, 
	ERROR_T=&gt; ERROR_T);
	
	

ELSE
MQTT(
	MQTT_INFO:= MQTT_INFO, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= enable, 
	URL:= 'test.mosquitto.org:1883', //8883 encryptet, 1883 unencryptet
	TIMEOUT:= T#5S, 
	TLS := FALSE,
	ERROR_C=&gt; ERROR_C, 
	ERROR_T=&gt; ERROR_T);
END_IF</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>e6632a47-4b1f-4808-9ba9-69205ba08238</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="TestPublishValue" pouType="functionBlock">
        <interface>
          <localVars>
            <variable name="MQTT">
              <type>
                <derived name="HANDLE_MQTT" />
              </type>
            </variable>
            <variable name="MQTT_INFO">
              <type>
                <derived name="MQTT_INFO" />
              </type>
            </variable>
            <variable name="MQTT_IN_OUT">
              <type>
                <derived name="MQTT_IN_OUT" />
              </type>
            </variable>
            <variable name="testPiublish">
              <type>
                <array>
                  <dimension lower="0" upper="100" />
                  <baseType>
                    <derived name="MQTTPublish" />
                  </baseType>
                </array>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">testPiublish: SD_MQTT.MQTTPublish;</xhtml>
              </documentation>
            </variable>
            <variable name="init">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="FALSE" />
              </initialValue>
            </variable>
            <variable name="sendTest">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="TestValue">
              <type>
                <array>
                  <dimension lower="0" upper="99" />
                  <baseType>
                    <derived name="MQTTValue" />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="testtime">
              <type>
                <derived name="ton" />
              </type>
            </variable>
            <variable name="i">
              <type>
                <UDINT />
              </type>
            </variable>
            <variable name="qos">
              <type>
                <derived name="QoS" />
              </type>
              <initialValue>
                <simpleValue value="2" />
              </initialValue>
            </variable>
            <variable name="sub1">
              <type>
                <derived name="MQTTSubscribe" />
              </type>
            </variable>
            <variable name="Values">
              <type>
                <array>
                  <dimension lower="0" upper="99" />
                  <baseType>
                    <derived name="CommonTypesAndFunctions.ALL_TYPES_UNION" />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="temp1">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="tmpPointer">
              <type>
                <derived name="CommonTypesAndFunctions.ALL_TYPES_UNION_POINTER" />
              </type>
            </variable>
            <variable name="MQTTretain">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="TRUE" />
              </initialValue>
            </variable>
            <variable name="enable">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="ERROR_C">
              <type>
                <DWORD />
              </type>
            </variable>
            <variable name="ERROR_T">
              <type>
                <BYTE />
              </type>
            </variable>
            <variable name="ValueTime">
              <type>
                <TIME />
              </type>
              <initialValue>
                <simpleValue value="TIME#5s0ms" />
              </initialValue>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">MQTT_IN_OUT.ClientID :='testCodesys';
MQTT_IN_OUT.COM_CONFIG.MaxPayloadSize :=50000;
MQTT_IN_OUT.COM_CONFIG.MaxTopicLevels := 200;
//testtime(IN:= , PT:= );
testtime(IN:= NOT testtime.Q AND sendTest, PT:= T#100MS);

//testtime(IN:= NOT testtime.Q AND sendTest, PT:= T#10S);
IF NOT init THEN
	init := TRUE;
	tmpPointer.POINTER_TO_LREAL_T := ADR(temp1);
	TestValue[0].Init(
	Topic:= ADR('Haus/Raum1/Tisch/'), 
	ValueName:= ADR('Temperatur'), 
	ValuePointer:= tmpPointer, 
	ValueType:= CommonTypesAndFunctions.VAR_TYPES.LREAL_T, 
	ValueDiff:= 1, 
	MQTT_IN_OUT:= ADR(MQTT_IN_OUT), 
	DecimalPlace:= 2, 
	QoS:= qos, 
	RetainMqtt:= MQTTretain,
	MinTime:=ValueTime);
	sub1.SetMqttInOut(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));

END_IF
TestValue[0]();


MQTT(
	MQTT_INFO:= MQTT_INFO, 
	MQTT_IN_OUT:= MQTT_IN_OUT, 
	ENABLE:= enable, 
	URL:= 'windows-10-pro:1883', 
	TIMEOUT:= T#5S, 
	ERROR_C=&gt; ERROR_C, 
	ERROR_T=&gt; ERROR_T);</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>aa9e1f7c-7bc1-4db0-be80-d6343d327e02</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="TestSubscribeOld" pouType="functionBlock">
        <interface>
          <localVars>
            <variable name="MQTT_IN_OUT">
              <type>
                <derived name="MQTT_IN_OUT" />
              </type>
            </variable>
            <variable name="subscribe">
              <type>
                <array>
                  <dimension lower="0" upper="20" />
                  <baseType>
                    <derived name="MQTTSubscribe" />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="init">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="i">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="recived">
              <type>
                <array>
                  <dimension lower="0" upper="20" />
                  <baseType>
                    <BOOL />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="CountSplitTopicSizeExceeded">
              <type>
                <ULINT />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">IF NOT init THEN
	init := TRUE;
	FOR i := 0 TO 20 DO
		subscribe[i].SetMqttInOut(MQTT_IN_OUT:= ADR(MQTT_IN_OUT));
	END_FOR
END_IF
MQTT_IN_OUT.OUT.DataRecived := TRUE;
MQTT_IN_OUT.InFree := TRUE;
(*
MQTT_IN_OUT.OUT.MqttTopic := 'r//test';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=0;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= '+//test', 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := '/rest/zt';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= '#', 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := '566//test/3565/356';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= '+//test/#', 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := 'test';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= 'test', 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := '/test/';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= 'test/', 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := 'test/test1';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= 'test/test1', 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := 'a/ret/test';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= 'a/+/test', 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := '/test/etwetre/';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= '/test/+',//no match !!!!!
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := '/test/etwetre';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= '/test/+',//match !!!!!!
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := '/finance';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= '+/+', //match
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := '/finance';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= '/+', //match
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := '/finance';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= '+',//no match 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := 'finance/test';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= 'finance/test/',//** 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := 'finance/test';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= 'finance/test',//?? 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := 'finance/test';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= 'finance/test/+',//?? 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);

MQTT_IN_OUT.OUT.MqttTopic := 'finance';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= 'finance/#',//?match
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := 'finance/';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= 'finance/#',// match 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := 'test/ff';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= 'test/ff/+',//no match 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
MQTT_IN_OUT.OUT.MqttTopic := 'test/ff';
//GetSplitTopic(in:= MQTT_IN_OUT.OUT.MqttTopic, Target:= ADR(MQTT_IN_OUT.OUT.Topics), CountSplitTopicSizeExceeded:= ADR(CountSplitTopicSizeExceeded));
i:=i+1;
subscribe[i](
	Subscribe:= TRUE, 
	Topic:= 'test/ff/#',//match 
	QoSSubscribe:= 0, 
	Payload=&gt; , 
	TopicOut=&gt; , 
	SendTimeout=&gt; , 
	SubscribeFail=&gt; , 
	TopicValid=&gt; , 
	Recived=&gt; recived[i]);
*)</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>00aa4d68-8bf8-4d2b-a7f7-d45d92feacef</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="TestTopicMatch" pouType="functionBlock">
        <interface>
          <localVars>
            <variable name="t1">
              <type>
                <derived name="SplitTopic" />
              </type>
            </variable>
            <variable name="t2">
              <type>
                <derived name="SplitTopic" />
              </type>
            </variable>
            <variable name="match">
              <type>
                <derived name="TOPIC_MATCH" />
              </type>
            </variable>
            <variable name="pts">
              <type>
                <array>
                  <dimension lower="0" upper="20" />
                  <baseType>
                    <pointer>
                      <baseType>
                        <string />
                      </baseType>
                    </pointer>
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="sp">
              <type>
                <pointer>
                  <baseType>
                    <derived name="SPLIT_TOPIC" />
                  </baseType>
                </pointer>
              </type>
            </variable>
            <variable name="COM_CONFIG">
              <type>
                <derived name="COM_CONFIG" />
              </type>
            </variable>
            <variable name="dynMemUsage">
              <type>
                <UDINT />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">t1.FullInit(TopicsLevelInit:= 40, SplitElementSizeInit:= 5000, dynMemUsageInit:= ADR(dynMemUsage));
t2.FullInit(TopicsLevelInit:= 40, SplitElementSizeInit:= 5000, dynMemUsageInit:= ADR(dynMemUsage));


t1.NewTopic(in:=ADR('/+/test/#'),test:= TRUE, SizeOfString:= 0);
	sp := t1.GetSplitTopic();
	pts[0] := sp^.Topics[0];
	pts[1] := sp^.Topics[1];
	pts[2] := sp^.Topics[2];
	pts[3] := sp^.Topics[3];
	pts[4] := sp^.Topics[4];
	pts[5] := sp^.Topics[5];
	pts[6] := sp^.Topics[6];
	pts[7] := sp^.Topics[7];
	pts[8] := sp^.Topics[8];
t2.NewTopic(in:=ADR('/rtt/test/tr'),test:= FALSE, SizeOfString:= 0);
	sp := t2.GetSplitTopic();
	pts[10] := sp^.Topics[0];
	pts[11] := sp^.Topics[1];
	pts[12] := sp^.Topics[2];
	pts[13] := sp^.Topics[3];
	pts[14] := sp^.Topics[4];
	pts[15] := sp^.Topics[5];
	pts[16] := sp^.Topics[6];
	pts[17] := sp^.Topics[7];
	pts[18] := sp^.Topics[8];
match := t1.CheckTopicMatchToMe(with:= t2.GetSplitTopic());


//test from MQTT doku
t1.NewTopic(in:=ADR('sport/tennis/+'),test:= TRUE, SizeOfString:= 0);
t2.NewTopic(in:=ADR('sport/tennis/player1'),test:= FALSE, SizeOfString:= 0);
match := t1.CheckTopicMatchToMe(with:= t2.GetSplitTopic()); //match
t2.NewTopic(in:=ADR('sport/tennis/player2'),test:= FALSE, SizeOfString:= 0);
match := t1.CheckTopicMatchToMe(with:= t2.GetSplitTopic());//match
t2.NewTopic(in:=ADR('sport/tennis/player1/ranking'),test:= FALSE, SizeOfString:= 0);
match := t1.CheckTopicMatchToMe(with:= t2.GetSplitTopic());//no match


t1.NewTopic(in:=ADR('sport/+'),test:= TRUE, SizeOfString:= 0);
t2.NewTopic(in:=ADR('sport'),test:= FALSE, SizeOfString:= 0);
match := t1.CheckTopicMatchToMe(with:= t2.GetSplitTopic()); //no match

t2.NewTopic(in:=ADR('sport/'),test:= FALSE, SizeOfString:= 0);
match := t1.CheckTopicMatchToMe(with:= t2.GetSplitTopic()); //match

t1.NewTopic(in:=ADR('+/+'),test:= TRUE, SizeOfString:= 0);
t2.NewTopic(in:=ADR('/finance'),test:= FALSE, SizeOfString:= 0);
match := t1.CheckTopicMatchToMe(with:= t2.GetSplitTopic()); //match

t1.NewTopic(in:=ADR('/+'),test:= TRUE, SizeOfString:= 0);
match := t1.CheckTopicMatchToMe(with:= t2.GetSplitTopic()); //match

t1.NewTopic(in:=ADR('+'),test:= TRUE, SizeOfString:= 0);
match := t1.CheckTopicMatchToMe(with:= t2.GetSplitTopic()); //no match
//just for breakpoint
t1.NewTopic(in:=ADR('+/+'),test:= TRUE, SizeOfString:= 0);


</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>d3ebd239-47a7-4078-8606-b8b2c7e92d0e</ObjectId>
          </data>
        </addData>
      </pou>
    </pous>
  </types>
  <instances>
    <configurations />
  </instances>
  <addData>
    <data name="http://www.3s-software.com/plcopenxml/globalvars" handleUnknown="implementation">
      <globalVars name="MyConstants" constant="true">
        <variable name="FB_BUFFER_SIZE">
          <type>
            <UINT />
          </type>
          <initialValue>
            <simpleValue value="5000" />
          </initialValue>
        </variable>
        <variable name="_COM_PAYLOAD_SIZE">
          <type>
            <UINT />
          </type>
          <initialValue>
            <simpleValue value="256" />
          </initialValue>
        </variable>
        <variable name="_MAX_TOPIC_LEVEL_SIZE">
          <type>
            <UINT />
          </type>
          <initialValue>
            <simpleValue value="255" />
          </initialValue>
          <documentation>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">_COM_STRING_SIZE:UINT:=COM_PAYLOAD_SIZE;</xhtml>
          </documentation>
        </variable>
        <variable name="_MAX_PARTS_AT_TOPIC">
          <type>
            <INT />
          </type>
          <initialValue>
            <simpleValue value="25" />
          </initialValue>
        </variable>
        <variable name="_SQL_DATA_BUFFER_SIZE">
          <type>
            <UINT />
          </type>
          <initialValue>
            <simpleValue value="200" />
          </initialValue>
        </variable>
        <variable name="NETWORK_BUFFER_LONG_SIZE">
          <type>
            <UINT />
          </type>
          <initialValue>
            <simpleValue value="4095" />
          </initialValue>
        </variable>
        <variable name="KEEP_ALIVE_TIME">
          <type>
            <DWORD />
          </type>
          <initialValue>
            <simpleValue value="8" />
          </initialValue>
        </variable>
        <variable name="SENDING_TIMEOUT">
          <type>
            <TIME />
          </type>
          <initialValue>
            <simpleValue value="TIME#4s0ms" />
          </initialValue>
        </variable>
        <variable name="REPEAT_TIMEOUT">
          <type>
            <TIME />
          </type>
          <initialValue>
            <simpleValue value="TIME#2s0ms" />
          </initialValue>
        </variable>
        <variable name="REORDER_VALUE">
          <type>
            <UINT />
          </type>
          <initialValue>
            <simpleValue value="50000" />
          </initialValue>
          <documentation>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">50000</xhtml>
          </documentation>
        </variable>
        <variable name="SUBSTRACTION_VALUE">
          <type>
            <UINT />
          </type>
          <initialValue>
            <simpleValue value="30000" />
          </initialValue>
          <documentation>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">20000</xhtml>
          </documentation>
        </variable>
        <variable name="_COUNT_SUBTOPIC_FROM_BROKER">
          <type>
            <UINT />
          </type>
          <initialValue>
            <simpleValue value="25" />
          </initialValue>
        </variable>
        <variable name="MAX_PUBREL_REPEATS">
          <type>
            <UINT />
          </type>
          <initialValue>
            <simpleValue value="10" />
          </initialValue>
        </variable>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
            <Attributes>
              <Attribute Name="qualified_only" Value="" />
            </Attributes>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>838b66a3-7c96-4a86-a453-6bfd80ff3824</ObjectId>
          </data>
        </addData>
      </globalVars>
    </data>
    <data name="http://www.3s-software.com/plcopenxml/globalvars" handleUnknown="implementation">
      <globalVars name="GVL_MQTT">
        <variable name="ProgNum">
          <type>
            <derived name="PROG_NUM" />
          </type>
          <documentation>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">Last Progamm stat for debug timeout exception</xhtml>
          </documentation>
        </variable>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
            <Attributes>
              <Attribute Name="qualified_only" Value="" />
            </Attributes>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>976dc25f-9617-40b0-bef6-a6cbfe28769f</ObjectId>
          </data>
        </addData>
      </globalVars>
    </data>
    <data name="http://www.3s-software.com/plcopenxml/interface" handleUnknown="implementation">
      <Interface name="PublishConnector" ObjectId="72c0276c-3a9f-41c1-adcf-3e9bc2962d6e">
        <addData />
      </Interface>
    </data>
    <data name="http://www.3s-software.com/plcopenxml/libraries" handleUnknown="implementation">
      <Libraries>
        <Library Name="#CAA Types" Namespace="CAA" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" DefaultResolution="CAA Types Extern, * (CAA Technical Workgroup)" />
        <Library Name="#CAA Behaviour Model" Namespace="CBM" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" DefaultResolution="CAA Behaviour Model, * (CAA Technical Workgroup)" />
        <Library Name="#CAA FB Factory" Namespace="FBF" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" DefaultResolution="CAA FB Factory, * (CAA Technical Workgroup)" />
        <Library Name="OSCAT NETWORK, 1.30 (OSCAT)" Namespace="OSCAT_NETWORK" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="SysFile, * (System)" Namespace="SysFile" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="SysTypes Interfaces, * (System)" Namespace="SysTypes" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="#Standard" Namespace="Standard" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" DefaultResolution="Standard, * (System)" />
        <Library Name="SysProcess, 3.5.7.0 (System)" Namespace="SysProcess" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="SysSem, 3.5.5.0 (System)" Namespace="SysSem" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="CmpErrors Interfaces, * (System)" Namespace="CmpErrors" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="BASIC, 3.3.3.0 (OSCAT)" Namespace="OSCAT_BASIC" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="CAA Memory, 3.5.12.0 (CAA Technical Workgroup)" Namespace="MEM" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="#IecSfc" Namespace="IecSfc" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="true" LinkAllContent="false" DefaultResolution="IecSfc, 3.4.2.0 (System)" />
        <Library Name="#Analyzation" Namespace="Analyzation" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="true" LinkAllContent="false" DefaultResolution="Analyzation, 3.5.2.0 (System)">
          <Parameters>
            <Parameter Name="TABLE_UPPER_BOUND" Value="15" />
            <Parameter Name="STRING_LENGTH_EXP" Value="255" />
            <Parameter Name="STRING_LENGTH_ADDRESS" Value="20" />
            <Parameter Name="STRING_LENGTH_COMMENT" Value="255" />
            <Parameter Name="STRING_LENGTH_OUTSTRING" Value="255" />
            <Parameter Name="TABLE_SHOW_VALID_ITEMS" Value="FALSE" />
          </Parameters>
        </Library>
        <Library Name="Time and Date, 3.5.7.0 (3S - Smart Software Solutions GmbH)" Namespace="Time_and_Date" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="#CommonTypsFunctions" Namespace="CommonTypesAndFunctions" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" DefaultResolution="Common Helper for development, * (Stefan Dreyer)" />
        <Library Name="SysTarget, 3.5.5.0 (System)" Namespace="SysTarget" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="Plc Services, 3.5.8.0 (System)" Namespace="Plc_Services" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="SysStr23, 3.5.13.0 (System)" Namespace="SysStr23" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="StringUtils, 3.5.13.0 (System)" Namespace="Stu" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="SysMem23, 3.5.13.0 (System)" Namespace="SysMem23" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="MemoryUtils, 3.5.13.0 (3S - Smart Software Solutions GmbH)" Namespace="MEMUtils" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="CAA File, 3.5.13.0 (CAA Technical Workgroup)" Namespace="FILE" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="CmpCrypto, 3.5.11.0 (System)" Namespace="CmpCrypto" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <Library Name="3S Storage, 3.5.13.0 (3S - Smart Software Solutions GmbH)" Namespace="STI" HideWhenReferencedAsDependency="false" PublishSymbolsInContainer="false" SystemLibrary="false" LinkAllContent="false" />
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>8c1463b5-02f2-427d-bd06-9e39d42fcbff</ObjectId>
          </data>
        </addData>
      </Libraries>
    </data>
    <data name="http://www.3s-software.com/plcopenxml/projectstructure" handleUnknown="discard">
      <ProjectStructure>
        <Object Name="Bibliotheksverwalter" ObjectId="8c1463b5-02f2-427d-bd06-9e39d42fcbff" />
        <Folder Name="MQTT">
          <Folder Name="Function Blocks">
            <Object Name="HANDLE_MQTT" ObjectId="de40940d-72fb-4911-9e82-a78a5e144b68">
              <Object Name="ResetPingTime" ObjectId="6b44b8d0-7adf-48d8-b75c-dd2acfbff3a1" />
              <Object Name="MakePingPaket" ObjectId="f2386f31-8fa4-46c4-b65c-985254494317" />
              <Object Name="StateMashineOut" ObjectId="76450c13-0057-4d67-9911-3a23329af831" />
              <Object Name="StateMashineIn" ObjectId="d87fe352-763e-4ff2-8fe2-b22ed364192e" />
              <Object Name="BuildPublishPaket" ObjectId="b579d915-d9ab-4cac-94a6-062255c7cdcc" />
              <Object Name="MoveBufferForSplitPaket" ObjectId="329db169-e7d1-4ba4-8fa9-f8151db084da" />
              <Object Name="BuildSubscribePaket" ObjectId="cda195a3-d851-43ea-b874-50b26c5632c5" />
              <Object Name="BuildUnsubscribePaket" ObjectId="688a96f0-99e0-4a03-95f7-16628eca43f4" />
              <Object Name="SendOutData" ObjectId="eaf44d39-53ab-4f9b-83b9-193ac4c883af" />
              <Object Name="SendInData" ObjectId="a7ea802c-6124-4ca3-9c46-9debb67a877b" />
              <Object Name="ParseIncoming" ObjectId="a0195934-de34-4282-bca7-4efe8c4c5b8c" />
              <Object Name="ParseIncomingPublish" ObjectId="e0043f8f-3a31-4d50-8659-2ad99197624b" />
              <Object Name="GetNextPublishFreePos" ObjectId="3dc7a6d6-b031-4ca1-848b-e6b55ba6c2ae" />
              <Object Name="CheckLenghtBuffer" ObjectId="d2d33c09-9dff-4eb5-b512-251000170b1a" />
              <Object Name="FB_Exit" ObjectId="b9c05d0c-ef6e-4249-9bbd-be68de915780" />
              <Object Name="destroy" ObjectId="4ec73c21-a461-466b-8611-c64366e7705a" />
              <Object Name="OutputPublish" ObjectId="41ef459f-dc94-4b40-9ac4-ceeadc73dff2" />
              <Object Name="MergeSplitedPublish" ObjectId="9d396c27-f37d-4dd3-95cd-3c260fb5beb7" />
              <Object Name="Publish" ObjectId="69dd8b32-66a3-4c6d-a9c4-38a21807fc8e" />
            </Object>
            <Object Name="MQTT_CONTROL" ObjectId="9b642721-ce73-4258-9e15-8e2406aa0c86" />
            <Object Name="MQTTPublish" ObjectId="cc2d5fcf-b68d-4e57-b744-68b746e30a3b" />
            <Object Name="MQTTBase" ObjectId="22db369a-9de1-444e-be59-cbfd328e69c6">
              <Object Name="SetMqttInOut" ObjectId="3e841b5d-b781-44dd-ba86-78e29089f6be" />
              <Object Name="CheckToken" ObjectId="d147036f-655b-41a3-9039-69fc31885cc5" />
              <Object Name="RequestToken" ObjectId="c76fd038-87b5-4695-8477-ac9be3fd0c0e" />
              <Object Name="ReleaseToken" ObjectId="61892de8-a34d-4b3a-82aa-a1e5b61fdca4" />
            </Object>
            <Object Name="MQTTSubscribe" ObjectId="dd71ef48-a746-409a-bd12-2cc36b1fc25e" />
            <Object Name="InsertSplitTopic" ObjectId="86a50c54-22c9-433f-91fe-823ead6df5b5">
              <Object Name="reset" ObjectId="1fcde2a6-7eb6-4266-9d66-95d21574ca96" />
            </Object>
            <Object Name="SplitTopic" ObjectId="42eb1e91-cc42-47d6-98e4-0b800a4d947f">
              <Object Name="FullInit" ObjectId="ceb1e346-4e57-4b78-8421-2c1d641d22cf" />
              <Object Name="LowInit" ObjectId="aee97ce3-b520-46d2-ba03-088505d4b950" />
              <Object Name="destroy" ObjectId="8cd22f1f-8fc7-489a-9664-9c5f3e657548" />
              <Object Name="GetSplitTopic" ObjectId="4fc0a7a2-e23b-474c-83c1-ce1bc25ea8e6" />
              <Object Name="FB_Exit" ObjectId="83390a32-5ae0-4d2a-9e1e-4f733a09628d" />
              <Object Name="NewTopic" ObjectId="5b35f434-7bb3-4f6b-8ddc-1205e223b0e8" />
              <Object Name="PushSplitLevel" ObjectId="2308047e-24eb-4016-a5c6-8ccd0f2d9c7f" />
              <Object Name="DestroyOldSplit" ObjectId="9fa76813-2029-4e6a-971b-f556bb4f82e5" />
              <Object Name="CheckTopicMatchToMe" ObjectId="40fb46a3-f73f-4707-8903-3d991face833" />
              <Object Name="CheckTopicValid" ObjectId="43d1c309-2ad2-4278-9176-896480b00081" />
            </Object>
            <Object Name="InsertSplitPayload" ObjectId="22733c41-86e3-41ca-bf60-527fc6a5bc73">
              <Object Name="reset" ObjectId="05ae8f49-4f21-4727-8495-50c84c2a2285" />
            </Object>
            <Object Name="MQTTValue" ObjectId="7cbccac7-37d7-452a-91d9-21795ebc51d9">
              <Object Name="Init" ObjectId="7761ef91-55fb-474b-8fce-5f93c68f1f9d" />
            </Object>
            <Object Name="MQTTState" ObjectId="45dda641-95c7-4e58-b79e-a2cab7a6bc2c">
              <Object Name="Init" ObjectId="1e403734-4c33-4f63-a784-3b0e0ec24e6c" />
            </Object>
          </Folder>
          <Folder Name="Global Constants">
            <Object Name="MyConstants" ObjectId="838b66a3-7c96-4a86-a453-6bfd80ff3824" />
          </Folder>
          <Folder Name="Function">
            <Object Name="InsertStringToBufferAndLength" ObjectId="ed441082-1d3e-463c-bc84-a704e7534de7" />
            <Object Name="DoRemainingLength" ObjectId="e2e73127-c450-4db7-8e16-8119af21d884" />
            <Object Name="GetRemainingLength" ObjectId="168ed935-d7fd-4c44-93c7-2a8614b8ecf9" />
            <Object Name="CheckTopicLevel" ObjectId="655f312f-4e19-41ff-9a48-b9cd257567fd" />
            <Object Name="DoRemainingLengthBevor" ObjectId="7a7085eb-fade-40fb-a106-1b3f7da54eb0" />
          </Folder>
          <Folder Name="Structs">
            <Object Name="MQTT_IN_OUT" ObjectId="55008e55-a327-4545-aaa7-3221c41bb9e1" />
            <Object Name="DATA_FROM_BROKER" ObjectId="32b50b35-fcff-4e03-852b-c3c9dacef9d9" />
            <Object Name="MQTT_INFO" ObjectId="32a39fb8-f516-444c-be3c-83354e376270" />
            <Object Name="MQTT_COM" ObjectId="5209abac-a19a-4b19-a65e-8a7aaacdb271" />
            <Object Name="DATA_TO_BROKER" ObjectId="8f262079-4448-4ad4-914c-e723074c16c8" />
            <Object Name="MQTT_IN_DATA" ObjectId="4c7c1bae-e8c3-425f-ac0b-be3e1bb059c6" />
            <Object Name="PAKET_DATA" ObjectId="562b289a-9159-4417-8182-cc4e81b366b8" />
            <Object Name="MQTT_OUT_DATA" ObjectId="ae326562-56be-495d-a72e-4a01b53e8ece" />
            <Object Name="REMAINING_LENGTH_RETURN" ObjectId="94c78556-e4a3-4405-aebc-1e66657239c5" />
            <Object Name="SPLIT_TOPIC" ObjectId="093130aa-4b04-4d26-9869-e5698edc6583" />
            <Object Name="SEND_INFOS" ObjectId="2bc87a2f-4743-4048-b61f-7cca24bbfb38" />
            <Object Name="RECIVE_PAKET" ObjectId="5ccc79d7-9560-4034-9035-9d8c8e8be5c7" />
            <Object Name="COM_CONFIG" ObjectId="f023999e-09e0-4a7b-bf94-bca33e8956a1" />
          </Folder>
          <Folder Name="ENUMs">
            <Object Name="MESSAGETYPE" ObjectId="f2b44ef8-0bd0-44af-8bb1-57f4cebd4fde" />
            <Object Name="QoS" ObjectId="dc0ab29a-e4c9-4251-b775-e8f4fc8a2ed4" />
            <Object Name="STEPS_OUT" ObjectId="959ee70e-6c1f-4f46-b4d6-2e47c7bb5ec5" />
            <Object Name="STEPS_IN" ObjectId="62f118e5-0ccc-4d99-91e8-1c5458854c9a" />
            <Object Name="INSERT_SPLIT_RETURN" ObjectId="bb4d1531-d91b-43d0-a2e0-94b8e19d747c" />
            <Object Name="TOPIC_VALID" ObjectId="f7ef1884-ffea-471c-909d-3b229bcf4d4a" />
            <Object Name="TOPIC_MATCH" ObjectId="2d2ca9f7-31bc-451a-aac6-7d56f3a3c2f7" />
            <Object Name="PROG_NUM" ObjectId="c96a8249-695b-4b97-a93f-d9c79b7ceae9" />
          </Folder>
          <Folder Name="TestCases">
            <Object Name="TestcaseCheckTopivValid" ObjectId="632e8e92-ad6c-45dd-90a7-c985f011dd34" />
            <Object Name="TestSubscribeOld" ObjectId="00aa4d68-8bf8-4d2b-a7f7-d45d92feacef" />
            <Object Name="PLC_PRG" ObjectId="889aed6b-4c51-400b-a3fa-ee165d5c3463" />
            <Object Name="TestMqtt" ObjectId="04fc90f3-c020-40ea-9831-93a03c452235" />
            <Object Name="TestMqttTLS" ObjectId="e6632a47-4b1f-4808-9ba9-69205ba08238" />
            <Object Name="TestTopicMatch" ObjectId="d3ebd239-47a7-4078-8606-b8b2c7e92d0e" />
            <Object Name="TestPublishValue" ObjectId="aa9e1f7c-7bc1-4db0-be80-d6343d327e02" />
            <Object Name="testHighRecive" ObjectId="2c7b7c99-a3d9-49b0-b749-8e7ba380eebe" />
          </Folder>
          <Object Name="GVL_MQTT" ObjectId="976dc25f-9617-40b0-bef6-a6cbfe28769f" />
          <Folder Name="Docs">
            <Object Name="Doku" ObjectId="19d5ffa0-ed0e-45b0-9ceb-9920b74e90c1" />
          </Folder>
          <Folder Name="Exampels">
            <Object Name="TestOutOfTheBoxNoTLS" ObjectId="7710ce00-c1ae-47be-931d-77aa31d80969" />
            <Object Name="TestOutOfTheBoxTLS" ObjectId="2f0f42d5-f5e7-4150-9177-534c70b72865" />
          </Folder>
          <Folder Name="Interfaces">
            <Object Name="PublishConnector" ObjectId="72c0276c-3a9f-41c1-adcf-3e9bc2962d6e" />
          </Folder>
        </Folder>
      </ProjectStructure>
    </data>
  </addData>
</project>